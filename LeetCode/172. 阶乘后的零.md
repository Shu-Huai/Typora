# 172. 阶乘后的零

给定一个整数 `n` ，返回 `n!` 结果中尾随零的数量。

提示 `n! = n * (n - 1) * (n - 2) * ... * 3 * 2 * 1`

**示例 1：** 

> **输入：** n = 3
>
> **输出：** 0
>
> **解释：** 3\! = 6 ，不含尾随 0

**示例 2：** 

> **输入：** n = 5
>
> **输出：** 1
>
> **解释：** 5\! = 120 ，有一个尾随 0

**示例 3：** 

> **输入：** n = 0
>
> **输出：** 0

**提示：** 

*   `0 <= n <= 10^4`

**进阶：** 你可以设计并实现对数时间复杂度的算法来解决此问题吗？

## 代码

### 数学家

```java
public int trailingZeroes(int n) {
    int sum = 0;
    for (int i = 1; i <= n; i++) {
        int cur = i;
        while (cur % 5 == 0) {
            sum++;
            cur /= 5;
        }
    }
    return sum;
}
```

- 时间复杂度 $O(n)$
- 空间复杂度 $O(1)$

### 天才数学家

```java
public int trailingZeroesClever(int n) {
    int sum = 0;
    while (n != 0) {
        n /= 5;
        sum += n;
    }
    return sum;
}
```

- 时间复杂度 $O(\log n)$
- 空间复杂度 $O(1)$

## 官解

### 数学

$n!$ 尾零的数量即为 $n!$ 中因子 10 的个数，而 $10=2×5$，因此转换成求 $n!$ 中质因子 2 的个数和质因子 5 的个数的较小值。

由于质因子 5 的个数不会大于质因子 2 的个数（具体证明见方法二），我们可以仅考虑质因子 5 的个数。

而 $n!$ 中质因子 5 的个数等于 $[1,n]$ 的每个数的质因子 5 的个数之和，我们可以通过遍历 $[1,n]$ 的所有 5 的倍数求出。

### 优化计算

换一个角度考虑 $[1, n]$ 中质因子 $p$ 的个数。

$[1, n]$ 中 $p$ 的倍数有 $n_1 = \left\lfloor \frac{n}{p} \right\rfloor$ 个，这些数至少贡献出了 $n_1$ 个质因子 $p$。$p^2$ 的倍数有 $n_2 = \left\lfloor \frac{n}{p^2} \right\rfloor$ 个，由于这些数已经是 $p$ 的倍数了，为了不重复统计 $p$ 的个数，我们仅考虑额外贡献的质因子个数，即这些数额外贡献了至少 $n_2$ 个质因子 $p$。

依此类推，$[1, n]$ 中质因子 $p$ 的个数为

$$
\sum_{k=1}^{\infty}\left\lfloor \frac{n}{p^k} \right\rfloor
$$

上式表明：

1. $n$ 不变，$p$ 越大，质因子个数越少，因此 $[1, n]$ 中质因子 $5$ 的个数不会大于质因子 $2$ 的个数；
2. $[1, n]$ 中质因子 $5$ 的个数为

$$
\sum_{k=1}^{\infty}\left\lfloor \frac{n}{5^k} \right\rfloor < \sum_{k=1}^{\infty}\frac{n}{5^k} = \frac{n}{4} = O(n)
$$

代码实现时，由于

$$
\left\lfloor \frac{n}{5^k} \right\rfloor = \left\lfloor \frac{\left\lfloor \frac{n}{5^{k-1}} \right\rfloor}{5} \right\rfloor
$$

因此我们可以通过不断将 $n$ 除以 $5$，并累加每次除后的 $n$，来得到答案。