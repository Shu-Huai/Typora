# 209. 长度最小的子数组

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。** 

找出该数组中满足其总和大于等于 `target` 的长度最小的**子数组**  `[nums_l, nums_l+1, ..., nums_r-1, nums_r]` ，并返回其长度**。** 如果不存在符合条件的子数组，返回 `0` 。

**示例 1：** 

> **输入：** target = 7, nums = \[2,3,1,2,4,3]
>
> **输出：** 2
>
> **解释：** 子数组 `[4,3]` 是该条件下的长度最小的子数组。

**示例 2：** 

> **输入：** target = 4, nums = \[1,4,4]
>
> **输出：** 1

**示例 3：** 

> **输入：** target = 11, nums = \[1,1,1,1,1,1,1,1]
>
> **输出：** 0

**提示：** 

*   `1 <= target <= 10^9`
*   `1 <= nums.length <= 10^5`
*   `1 <= nums[i] <= 10^4`

**进阶：** 

*   如果你已经实现 `O(n)` 时间复杂度的解法, 请尝试设计一个 `O(n log(n))` 时间复杂度的解法。

## 代码

## 官解

### 暴力法

暴力法是最直观的方法。初始化子数组的最小长度为无穷大，枚举数组 $nums$ 中的每个下标作为子数组的开始下标，对于每个开始下标 $i$，需要找到大于或等于 $i$ 的最小下标 $j$，使得从 $nums[i]$ 到 $nums[j]$ 的元素和大于或等于 $s$，并更新子数组的最小长度（此时子数组的长度是 $j−i+1$）。

注意：使用 Python 语言实现方法一会超出时间限制。

### 前缀和 + 二分查找

