# 算法设计与分析

## 第1 章 算法概述

### 算法的非正式定义

算法是一系列解决问题的清晰指令，即对符合一定规范的输入，在有限时间内获得所要求的输出。

<img src="http://public.file.lvshuhuai.cn/images\image-20241127155152211.png" alt="image-20241127155152211" style="zoom:50%;" />

### 关于算法的几个要点

- 算法的每个步骤都必须清晰、明确，不含糊
- 算法所处理的值域必须仔细定义。
- 同样一种算法可以用不同的形式描述。
- 同一个问题可能存在不同的解决算法。
- 同一个问题的不同算法不仅解题思路不同，而且解题速度可能有显著差别。

### 算法与程序

#### 算法是满足下述性质的指令序列

1. 输入
    有零个或多个外部量作为算法的输入。
2. 输出
    算法产生至少一个量作为输出。
3. 确定性
    组成算法的每条指令清晰、无歧义
4. 有限性
    算法中每条指令的执行次数、时间有限

#### 程序

是算法用某种程序设计语言的具体实现

程序可不满足算法性质有限性

### 问题求解

<img src="http://public.file.lvshuhuai.cn/images\image-20241127155421961.png" alt="image-20241127155421961" style="zoom:50%;" />

### 算法举例

#### 计算两个正整数 $m$、$n$ 的最大公约数

##### 欧几里德算法

$gcd(m,n)$，其中 $m\ge n$，其递归定义为 $gcd⁡(m,n)=\left\lbrace\begin{aligned}&m&,n=0\\\\&gcd(n,m\mod n)&,n>0\end{aligned}\right.$

自然语言描述

1. 第一步：如果 $n=0$，返回 $m$ 的值作为结果同时过程结束；否则，进入第二步
2. 第二步：用 $n$ 去除 $m$，将余数赋给 $r$。
3. 第三步：将 $n$ 的值赋给 $m$，将 $r$ 的值赋给 $n$，返回第一步

伪代码描述

高级语言描述

```java
public int euclid(int m, int n) {
    while (n != 0) {
        int r = m % n;
        m = n;
        n = r;
    }
    return m;
}
```

##### 连续整数检测算法

算法思想

基于最大公约数的定义：同时整除两个整数的最大整数

显然，不会大于两数较小者。故令：$t=\min{m,n}$ 用 $t$ 除 $m,n$，若除尽，$t$ 即最大公约数；否则令 $t=t−1$，继续尝试。

Java语言描述

```java
public int loop(int m, int n) {
    int result = Math.min(m, n);
    while (result > 0) {
        if (m % result == 0 && n % result == 0) {
            return result;
        }
        result--;
    }
    return 0;
}
```

##### 中学里计算

把 $2,\cdots,n$ 之间的所有素数找出来，逐个逐个测试出 $m,n$ 中包含的公共素因子，将公共的素因子相乘就得到最大公约数

**埃拉托色尼筛算法**

1. 首先初始化一个 $2,\cdots,n$ 的连续序列，作候选素数。
2. 第一个循环消去 2 的倍数；
3. 然后，指向序列的下一个数字 3，消去其倍数；
4. 接下来指向 5，消去其倍数；
5. 按此方法不断做下去，直到序列中没有可消元素

Java语言描述

```java
public int prime(int m, int n) {
    if (m == n) {
        return m;
    }
    if (m % n == 0) {
        return n;
    }
    if (n % m == 0) {
        return m;
    }
    boolean[] isPrime = new boolean[n];
    Arrays.fill(isPrime, true);
    isPrime[0] = false;
    int count = 0;
    for (int i = 1; i < n; i++) {
        if (isPrime[i]) {
            int temp = i + 1;
            temp += i + 1;
            while (temp <= n) {
                if (isPrime[temp - 1]) {
                    isPrime[temp - 1] = false;
                    count++;
                }
                temp += i + 1;
            }
        }
    }
    int[] primes = new int[n - count - 1];
    count = 0;
    for (int i = 0; i < n; i++) {
        if (isPrime[i]) {
            primes[count++] = i + 1;
        }
    }
    int result = 1;
    while (Arrays.binarySearch(primes, m) < 0 && Arrays.binarySearch(primes, n) < 0
            && !(Arrays.binarySearch(primes, m) >= 0 && m < n)
            && !(Arrays.binarySearch(primes, n) >= 0 && m > n)) {
        for (int j : primes) {
            if (m % j == 0 && n % j == 0) {
                m /= j;
                n /= j;
                result *= j;
                break;
            }
        }
    }
    return result;
}
```

### 算法的复杂性分析

算法复杂性是算法运行所需的计算机资源量

需要的时间资源的量称为时间复杂性，$T=T(N,I)$

需要的空间资源的量称为空间复杂性，$S=S(N,I)$

$N$ 代表问题的规模，$I$ 代表输入（实例）

时间复杂性是输入为时的跟规模 $n$ 相关的算法运行时间增长率

空间复杂性是输入为时的跟规模 $n$ 相关的算法辅助空间增长率

**算法复杂性的分析**：算法的能行性。$n!$，$2^n$，$n$ 较大时

**同一问题不同算法的复杂性分析**：算法的优劣

空间复杂性与时间复杂性的分析方法类同，主要讨论时间复杂性

对于所有的实例进行分析是不现实的，通常分析：最坏情况、最好情况、平均情况三种。

**最坏情况下的时间复杂性**

$$T_{\max}(N)=\max_{I\in D_N} T(N, I)=\max_{I\in D_N}\sum_{i=1}^k t_i e_i(N, I)=\sum_{i=1}^k t_i e_i(N, I^\ast)=T(N, I^\ast)$$

**最好情况下的时间复杂性**

$$T_{\min}(N)=\min_{I\in D_N} T(N, I)=\min_{I\in D_N}\sum_{i=1}^k t_i e_i(N, I)=\sum_{i=1}^k t_i e_i(N,\widetilde{I})=T(N,\widetilde{I})$$

**平均情况下的时间复杂性**

$$T_{avg}(N)=\sum_{I\in D_N} P(I) T(N, I)=\sum_{I\in D_N} P(I)\sum_{i=1}^k t_i e_i(N, I)$$

一般情况下，我们讨论算法在最坏情况下的时间复杂性。最好情况下的时间复杂性是特例下发生，意义不大。

如果能保证在最坏情况下的时间复杂性是理想的，算法是能行的，又对于问题的解决才有意义。

算法时间复杂性分析分为二类

1. 非递归算法的时间复杂性分析
2. 递归算法的时间复杂性分析

两种类型的分析方法有所不同

#### 算法复杂性在渐近意义下的阶

渐近意义下的记号：$O$、$\Omega$、$\Theta$、$o$、$\omega$

$g(n)$ 是定义在正数集上的正函数。$T(n)$ 为算法的时间复杂性，$n$ 是数据规模

##### 渐近上界记号 $O$

若 $T(n)=O(g(n))$

含义：算法在任何实例情况下，其时间复杂性的阶不超过 $g(n)$ 的阶

即 $\lim_{n\rightarrow\infty}\frac{T_{\max}(n)}{g(n)}=c\ne0$，$c$ 为常数

##### 渐近下界记号 $\Omega$

若 $T(n)=Ω(g(n))$

含义：算法在任何实例情况下，其时间复杂性的阶不低于 $g(n)$ 的阶

即 $\lim_{n\rightarrow\infty}\frac{T_{\min}(n)}{g(n)}=c\ne0$，c为常数

##### 记号 $\Theta$

若 $T(n)=O(g(n))=\Omega(g(n))$，则 $T(n)=\Theta(g(n))$

##### 紧渐近上界记号 $o$

若 $T(n)= o(g(n))$

含义：算法在任何实例情况下，其算法时间复杂性的阶小于 $g(n)$ 的阶

即 $\lim_{n\rightarrow\infty}\frac{T_{\max}(n)}{g(n)}=0$ 

##### 非紧渐近下界记号 $\omega$

若 $T(n)=\omega(g(n))$

含义：算法在任何实例情况下，其时间复杂性的阶大于 $g(n)$ 的阶

即 $\lim_{n\rightarrow\infty}\frac{T_{\min}(n)}{g(n)}=0$

#### 算法的 $O$ 记号的快速分析步骤

1. 找出算法最坏情况下被执行次数最多的代码段，一般是循环嵌套次数最多的循环体
2. 计算这部分指令被执行的次数。

#### 常见的复杂性函数

$$C\rightarrow\log⁡ n\rightarrow\log^2n\rightarrow n\rightarrow n\log ⁡n\rightarrow n^2\rightarrow n^3\rightarrow 2^n\rightarrow n!$$

#### 最优算法

问题的计算时间下界为 $\Omega(f(n))$，则计算时间复杂性为 $O(f(n))$ 的算法是最优的。

### 递归算法时间复杂性的计算

#### 递推方法求递归算法的时间复杂性

通过递推方程，计算得到

#### Master定理方法求递归算法时间复杂性

第二章分治策略中，通常设计为递归算法

其时间复杂性的递归定义一般有如下形式

$T(n)=\left\lbrace\begin{aligned}&O(1)&,n=n_0\\\\&aT(\frac{n}{b})+n^k&,n>n_0\end{aligned}\right.$

使用 Master 定理方法可以快速求解该方程，这里要求 $a\ge1,b>1$ 为整数，$f(n)$ 是正函数

方法

1. 首先根据递归方程确定 $n^{\log_ba}$ 
2. 如果 $a>b^k$，则 $T(n)=O(n^{\log_ba})$
3. 如果 $a=b^k$，则 $T(n)=O(n^k\log n)$
4. 如果 $a<b^k$，则 $T(n)=O(N^k)$

#### 递归树求解递归方程

递归树是迭代计算模型

递归树的生成过程与选代过程一致

根据递归定义不断扩展递归树，直到边界条件（其值已知）

对递归树产生的所有项求和就是递归方程的解

## 递归与分治策略

### 分治法思想：分+治+合

分治法的设计思想是，将一个难以直接解决的大问题，分割成一些规模较小的相同问题，以便各个击破，分而治之。

<img src="http://public.file.lvshuhuai.cn/images\image-20241128104920481.png" alt="image-20241128104920481" style="zoom:50%;" />

### 分治与递归

#### 分治法

分治法产生的子问题是原问题的较小模式。

反复应用分治手段，可以使子问题规模不断缩小

最终使子问题缩小到很容易直接求出其解。

将规模较小问题的答案逐级向上合并，可得大问题答案

#### 递归过程

分治法解决问题通常使用递归算法

直接或间接地调用自身的算法称为递归算法

### 递归的概念

#### 递归算法的框架

<img src="http://public.file.lvshuhuai.cn/images\image-20241128105321477.png" alt="image-20241128105321477" style="zoom:50%;" />

#### 阶乘函数

$$ n!=\left\lbrace\begin{array}{ll} 1& n=0\\\\ n(n-1)! & n>0\end{array}\right.$$

#### Fibonacci 数列

$$ F(n)=\left\lbrace\begin{array}{ll} 1& n=0\\\\ 1& n=1\\\\ F(n-1)+F(n-2) & n>1\end{array}\right.$$

#### Ackerman 函数

双递归函数

$$A(n, m)=\left\lbrace\begin{array}{ll} 2& n=1, m=0\\\\ 1& n=0, m\geq 0\\\\ n+2& n\geq 2, m=0\\\\ A(A(n-1, m), m-1) & n, m\geq 1\end{array}\right.$$

Ackerman 函数找不到非递归的定义，只能使用递归算法实现

一个问题有递归和非递归定义，可使用递归或非递归算法实现。

#### 排列问题

设计一个递归算法生成 $n$ 个元素 $\left\lbrace r_1, r_2,\cdots, r_n\right\rbrace$​ 的全排列。

设 $R=\left\lbrace r_1, r_2,\cdots, r_n\right\rbrace$ 是要进行排列的 $n$ 个元素, $R_i=R-\left\lbrace r_i\right\rbrace$。集合 X中元素的全排列记为 $\operatorname{perm}(X)$。$(r_i)\operatorname{perm}(X)$ 表示在全排列 $\operatorname{perm}(X)$ 的每一个排列前加上前缀得到的排列。$R$ 的全排列可归纳定义如下：

当 $n=1$ 时, $\operatorname{perm}(R)=(r)$, 其中 $r$ 是集合 $R$ 中唯一的元素

当 $n>1$ 时, $\operatorname{perm}(R)$ 由 $\left(r_1\right)\operatorname{perm}\left(R_1\right),\left(r_2\right)\operatorname{perm}\left(R_2\right),\cdots,\left(r_n\right)\operatorname{perm}\left(R_n\right)$ 构成。

#### 汉诺塔问题

设 $a,b,c$ 是 3 个塔座。要求由 $a$ 移动到 $b$。移动圆盘时遵守以下移动规则

1. 每次只能移动 1 个圆盘；
2. 任何时刻都不允许较大的圆盘压在较小的圆盘之上；
3. 在满足移动规则的前提下，可将圆盘移至 $a,b,c$​中任一塔座上。

<img src="http://public.file.lvshuhuai.cn/images\image-20241128110219532.png" alt="image-20241128110219532" style="zoom:50%;" />

##### 算法描述

```java
public void recursive(int n, int a, int b, int c) {
    if (n == 0) {
        return;
    }
    recursive(n - 1, a, c, b);
    System.out.println(a + "->" + b);
    recursive(n - 1, c, b, a);
}
```

#### 递归小结

##### 优点

结构清晰，可读性强，而且容易用数学归纳法来证明算法的正确性，因此它为设计算法、调试程序带来很大方便。

##### 缺点

递归算法的运行效率较低，无论是耗费的计算时间还是占用的存储空间都比非递归算法要多

##### 建议

如果问题用递推方法可解决，就不要使用递归算法。

用栈模拟的非递归算法，对运行效率改善有限，不建议使用

### 分治法的适用条件

分治法所能解决的问题一般具有以下几个特征

1. 该问题的规模缩小到一定的程度就可以容易地解决
2. 该问题可以分解为若干个规模较小的相同问题——最优子结构性质
3. 利用该问题分解出的子问题的解可以合并为该问题的解——最优子结构性质
4. 该问题所分解出的各个子问题是相互独立的。——无重复子问题

### 分治法的基本步骤

```java
divide-and-conquer(P) {
    if (|P | <=n0){
        adhoc(P);//解决小规模的问题
    }
    divide P into smaller subinstances P1, P2,...,Pk//分解问题
    for (i = 1, i <= k, i++) {
        yi = divide - and - conquer(Pi); //递归的解各子问题
    }
    return merge(y1,...,yk); //各子问题的解合并为原问题的解
}
```

将一个问题分成大致相等的k个子问题，算法最有效。——平衡子问题思想

### 分治法的复杂性分析

分治法将规模为 $n$ 的问题分成 $k$ 个规模为 $\frac{n}{m}$ 的子问题去解

设分解阈值 $n=1$ 且adhoc 解规模为 1 的问题耗费 1 个单位时间

设将原问题分解为 $k$ 个子问题以及用 merge 将 $k$ 个子问题的解合并为原问题的解需用 $f(n)$ 个单位时间

用 $T(n)$ 表示分治法解规模为 $|P|=n$ 的问题所需的计算时间

$$T(n)=\left\lbrace\begin{array}{ll} O(1)& n=1\\\\ kT(\frac{n}{m})+f(n)& n>1\end{array}\right.$$

### 二分搜索技术

非递减序的 $n$ 个元素 $a[0:n−1]$，现要在这 $n$ 个元素中找出一特定元素 $x$

#### 分析

一个子问题 $[l:r],r<l$ 时，表示没有任何元素，返回 -1

设在 $a[l:r]$ 中找 $x$，$mid=\frac{l+r}{2}$

如果 $x==a[mid]$，则找到

如果 $x<a[mid]$，则继续在 $a[l,mid−1]$ 中找 $x$ 即可

如果 $x>a[mid]$，则继续在 $a[mid+1,r]$ 中找 $x$ 即可

子问题答案就是大问题的答案

#### 算法实现

```java
public int loop(int[] nums, int target) {
    int length = nums.length;
    int left = 0;
    int right = length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) {
            return mid;
        } else if (nums[mid] > target) {
            right = mid - 1;
        } else {
            left = mid + 1;
        }
    }
    return -1;
}
public int recursive(int[] nums, int target, int left, int right) {
    if (left > right) {
        return -1;
    }
    int mid = left + (right - left) / 2;
    if (nums[mid] == target) {
        return mid;
    }
    if (nums[mid] > target) {
        return recursive(nums, target, left, mid - 1);
    }
    return recursive(nums, target, mid + 1, right);
}
```

#### 时间复杂度

递归方程

$$T(n)=\left\lbrace\begin{array}{ll} O(1)& n=0\\\\ T(\frac{n}{2})+1& n\ge1\end{array}\right.$$

利用主定理或递归树可求其时间复杂性为 $O(\log n)$

### 快速幂算法

给定实数 $a$ 和非负整数 $n$，用分治法设计求 $a^n$ 的快速算法

#### 传统方法

循环 $n$ 次，每次将 $a$ 乘入结果

时间复杂度 $O(n)$

#### 分析

$$a^n = \left\lbrace
\begin{array}{ll}
0 & a = 0 \\\\
1 & n = 0 \\\\
\left(a^{\frac{n}{2}}\right)^2 & n > 0, n \text{为偶数} \\\\
\left(a^{\frac{n}{2}}\right)^2 * a & n > 0, n \text{为奇数}
\end{array}
\right.$$

#### 递归算法

##### 算法实现

```java
public int recursive(int a, int n) {
    if (a == 0) {
        return 0;
    }
    if (n == 0) {
        return 1;
    }
    int result = recursive(a, n / 2);
    if (n % 2 == 0) {
        return result * result;
    }
    return result * result * a;
}
```

##### 时间复杂度

$O(\log n)$

#### 非递归算法

例 $a^{93}$

93 的二进制

<img src="http://public.file.lvshuhuai.cn/images\image-20241128150125474.png" alt="image-20241128150125474" style="zoom:50%;" />

因此 $a^{93}$ 可转化为 $a^{64} a^{16} a^8 a^4 a$

从 1 开始，算 $a$ 的各次方，如果出现在二进制中为1，则将当前次方乘入最终结果中

##### 算法实现

```java
public int loop(int a, int n) {
    int result = 1;
    while (n > 0) {
        if (n % 2 == 1) {
            result *= a;
        }
        n /= 2;
        a *= a;
    }
    return result;
}
```

##### 时间复杂度

$O(\log n)$

### Strassen矩阵乘法

#### 传统方法

$A$ 和 $B$ 的乘积矩阵 $C$ 中的元素 $C[i][j]$ 定义为

$$C[i][j]=\sum_{k=1}^{n}{A[i][k]B[k][j]}$$

若依此定义来计算 $n\times n$ 矩阵 $A$ 和 $B$ 的乘积矩阵 $C$，$C$ 有 $n\times n$ 个元素，每计算 $C$ 的一个元素 $C[i][j]$ 需要做 $n$ 次乘法和 $n−1$ 次加法。因此，算出矩阵 $C$ 的个元素所需的计算时间复杂性为 $O(n^3)$

#### 分治法

将矩阵 $A$，$B$ 和 $C$ 中每一矩阵都分块成 4 个大小相等的子矩阵。

由此可将方程 $C=A B$ 重写为

$$
\begin{align*}
&\left(
\begin{array}{ll}
C_{11}& C_{12}\\\\
C_{21}& C_{22}
\end{array}
\right)=
\left(
\begin{array}{ll}
A_{11}& A_{12}\\\\
A_{21}& A_{22}
\end{array}
\right)
\left(
\begin{array}{ll}
B_{11}& B_{12}\\\\
B_{21}& B_{22}
\end{array}
\right) \\
\end{align*}
$$

$$C_{11}=A_{11} B_{11}+A_{12} B_{21}$$
$$C_{12}=A_{11} B_{12}+A_{12} B_{22} $$
$$C_{21}=A_{21} B_{11}+A_{22} B_{21} $$
$$C_{22}=A_{21} B_{12}+A_{22} B_{22}$$

##### 时间复杂度

$$
T(n)=\left\lbrace
\begin{array}{ll}
O(1)& n=2\\\\
8 T\left(\frac{n}{2}\right)+O(n^2) & n>2
\end{array}
\right.
$$

$$T(n)=O(n^3)$$

没有改进

#### 为了降低时间复杂度，必须减少乘法的次数

令

$$M_1=A_{11}(B_{12}-B_{22})$$
$$M_2=(A_{11}+A_{12})B_{22}$$
$$M_3=(A_{21}+A_{22})B_{11}$$
$$M_4=A_{22}(B_{21}-B_{11})$$
$$M_5=(A_{11}+A_{22})(B_{11}+B_{22})$$
$$M_6=(A_{12}-A_{22})(B_{21}+B_{22})$$
$$M_7=(A_{11}-A_{21})(B_{11}+B_{12})$$

则

$$C_{11}=M_5+M_4-M_2+M_6$$
$$C_{12}=M_1+M_2$$
$$C_{21}=M_3+M_4$$
$$C_{22}=M_5+M_1-M_3-M_7$$

##### 复杂度分析

$$
T(n)=\left\lbrace
\begin{array}{ll}
O(1)& n=2\\\\
7 T\left(\frac{n}{2}\right)+O(n^2) & n>2
\end{array}
\right.
$$

$$T(n)=O(n^{\log 7})=O(n^{2.81})$$

较大的改进