# 算法设计与分析（3）——动态规划

## 算法总体思想

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题

但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次

如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。

## 动态规划基本步骤

1. 找出最优解的性质，并刻划其结构特征（最优子结构性质）
2. 递归地定义最优值。
3. 以自底向上的方式计算出最优值
4. 根据计算最优值时得到的信息，构造最优解

## 矩阵连乘问题

### 问题叙述

给定 $n$ 个矩阵 $A_1,A_2,\cdots,A_n$，其中，$A_i$ 与 $A_{i+1}$ 是可乘的，$i=1,2,\cdots,n-1$，现要计算出这 $n$ 个矩阵的连乘积 $A_1A_2\cdots A_n$。

矩阵连乘问题：确定一种运算次序，使总的运算次数达到最少。

#### 矩阵乘法

$A=\left(a_{ij}\right)_{m\times k}，B=\left(b_{ij}\right)_{k\times n}，C=\left(c_{ij}\right)_{m\times n}，c_{ij}=\sum_{t=1}^{k}{a_{it}b_{tj}}$

计算 $C$：每个元素需 $k$ 次乘法，$k-1$ 次加法
$C$ 有 $mn$ 个元素：计算 $C$，需 $mnk$ 次乘法，$mn\left(k-1\right)$ 次加法

矩阵连乘方法数与添括号方式数一一对应

完全加括号的矩阵连乘积可递归地定义为

1. 单个矩阵是完全加括号的；
2. 若矩阵连乘积A是完全加括号的，则 $A$ 可表示为 2 个完全加括号的矩阵连乘积B和C的乘积并加括号，即 $A=\left(BC\right)$

### 算法分析

#### 穷举法

列举所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序

$n$ 个矩阵的连乘积，设不同的计算次序为 $P\left(n\right)$。因每种加括号方式都可以分解为两个子矩阵的括号问题：$\left(A_1\cdots A_k\right)\left(A_{k+1}\cdots A_n\right)$，故 $P\left(n\right)$ 的递推式如下：$P(n)=\left\lbrace\begin{aligned}&1&n=1\\\\&\sum_{k=1}^{n-1}{P(k)P(n-k)}&n>1\end{aligned}\right.\Rightarrow P(n)=\Omega(\frac{4^{n-1}}{(n-1)^{\frac{3}{2}}})$

#### 动态规划

##### 首先分析最优解的结构

将矩阵连乘积 $A_iA_{i+1}\cdots A_j$ 简记为 $A\left[i:j\right]$，这里 $i\le j$

考察计算 $A\left[i:j\right]$ 的最优计算次序，设这个计算次序在矩阵 $A_k$ 和 $A_{k+1}$ 之间将矩阵链断开，$i\le k<j$，则其相应完全加括号方式为$\left(A_iA_{i+1}\cdots A_j\right)=\left(\left(A_iA_{i+1}\cdots A_k\right)\left(A_{k+1}A_{k+2}\cdots A_j\right)\right)$

特征：计算 $A\left[i:j\right]$ 的最优次序所包含的计算矩阵子链 $A\left[i:k\right]$ 和 $A\left[k+1:j\right]$ 的次序也是最优的

- $m\left[i,j\right]$ 表示 $A\left[i:j\right]$ 的计算量
- $A\left[i:k\right]$ 的计算量为 $m\left[i,k\right]$
- $A\left[k+1:j\right]$ 的计算量为 $m\left[k+1,j\right]$
- 因此：$m\left[i,j\right]=m\left[i,k\right]+m\left[k+1,j\right]+p_{i-1}p_kp_j$
- 用反证法可证明，$m\left[i,j\right]$ 是最优值，则 $m\left[i,k\right]$，$m\left[k+1,j\right]$ 一定也是最优值
- 这里 $A_i$ 的维数为 $p_{i-1}\times p_i$

矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质，可用动态规划算法求解的显著特征

##### 建立递归关系

设计算 $A\left[i:j\right],1\le i\le j\le n$所需的最少数乘次数 $m\left[i,j\right]$，则原问题的最优值为 $m\left[1,n\right]$

当 $i=j$ 时，$A[i:j]=A_i$, 因此 $m\left[i,i\right]=0,i=1,2\cdots,n$

当 $i<j$ 时，$m\left[i,j\right]=m\left[i,k\right]+m\left[k+1,j\right]+p_{i-1}p_kp_j$，这里 $A_i$ 的维数为 $p_{i-1}\times p_i$

$m\left[i,j\right]=\left\lbrace\begin{aligned}&0&i=j\\\\&\min_{i\le k<j}{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j}&i<j\end{aligned}\right.$

$k$ 的位置只有 $j-i$ 种可能

##### 以自底向上的方式求最优值

对于 $1\le i\le j\le n$ 不同的有序对 $\left(i,j\right)$ 对应于不同的子问题。

因此，不同子问题的个数共有：$\binom{n}{2}=\left(n^2\right)$

用动态规划算法解此问题，可依据其递归式以自底向上的方式进行计算。

保存已解决的子问题答案。每个子问题只计算一次，需要时只要查一下子问题的结果，避免大量的重复计算，最终得到多项式时间的算法

##### 代码实现

```java
public List<Object> min(int[] p) {
    int[][] m = new int[p.length][p.length];
    int[][] s = new int[p.length][p.length];
    for (int i = 1; i < p.length; i++) {
        m[i][i] = 0;
    }
    for (int r = 2; r < p.length; r++) {
        for (int i = 1; i + r - 1 < p.length; i++) {
            int j = i + r - 1;
            int min = Integer.MAX_VALUE;
            for (int k = i; k < j; k++) {
                int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (t < min) {
                    min = t;
                    s[i][j] = k;
                }
            }
            m[i][j] = min;
        }
    }
    Queue<int[]> q = new LinkedList<>();
    Stack<String> stack = new Stack<>();
    q.offer(new int[]{1, p.length - 1});
    while (!q.isEmpty()) {
        int[] cur = q.poll();
        if (cur[0] == cur[1]) {
            stack.push(" " + cur[0] + " ");
            continue;
        }
        int k = s[cur[0]][cur[1]];
        q.offer(new int[]{cur[0], k});
        q.offer(new int[]{k + 1, cur[1]});
    }
    while (stack.size() > 1) {
        String first = stack.pop();
        String second = stack.pop();
        int firstNum = getNum(first);
        int secondNum = getNum(second);
        if (firstNum > secondNum) {
            String temp = first;
            first = second;
            second = temp;
        }
        String cur = "(" + first + second + ")";
        stack.push(cur);
    }
    return new ArrayList<>() {{
        add(m[1][p.length - 1]);
        add(stack.pop());
    }};
}
private int getNum(String str) {
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) != '(' && str.charAt(i) != ' ') {
            int j = i + 1;
            for (; j < str.length(); j++) {
                if (str.charAt(j) == ')' || str.charAt(j) == ' ') {
                    return Integer.parseInt(str.substring(i, j));
                }
            }
            if (j == str.length()) {
                return Integer.parseInt(str.substring(i, j));
            }
        }
    }
    return 0;
}
```

##### 复杂度

算法主要计算量取决于算法中子问题的数量，已知为 $O\left(n^2\right)$，求每个子问题的最优值的时间复杂性 $O\left(n\right)$（即 $k$ 控制循环次数最大值），因此算法的计算时间上界 $O\left(n^3\right)$。

算法所占用的辅助空间显然为 $O\left(n^2\right)$。

## 动态规划算法的基本要素

### 最优子结构

矩阵连乘计算次序问题的最优解包含着其子问题的最优解。此称为最优子结构性质。最优子结构是可用动态规划算法求解的前提。

问题的最优子结构性质证明

- 先假设由原问题的最优解导出的子问题的解不是最优的，再设法证明在这假设下可构造出比原问题最优解更好的解导致矛盾。

利用问题最优子结构性质，以自底向上的方式通过子问题的最优解逐步构造出整个问题的最优解。

### 重叠子问题

在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质

### 备忘录方法

备忘录方法与直接递归方法的控制结构相同

区别

- 备忘录方法为每个求解过的子问题建立了备忘录
- 求解一个子问题时先检查是否已有答案，避免重复求解

### 动态规划算法的特点

- 阶段性
  - 计算最优值是分阶段进行的
  - 如矩阵连乘问题
    1. 先计算所有只有一个矩阵的情况
    2. 再计算所有二个相邻矩阵连乘的情况
    3. 再计算所有三个相邻矩阵连乘的情况
    4. ⋯
    5. 最后计算 $n$ 个矩阵连乘的情况
- 无后向性
  - 是指已经计算出的子问题的答案不能再更改
  - 如 Dijkstra 算法是有后向性的例子（用贪心算法解决的问题）

## 数字塔问题

自塔顶可沿箭头所示方向移动到底层，问如何移动使得路径上的数字和最大？其数字和是多少？

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224041277.png" alt="image-20241201224041277" style="zoom:50%;" />

### 存储问题

数字塔的矩阵 $A$ 表示

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224107610.png" alt="image-20241201224107610" style="zoom:50%;" />

数字和的矩阵 $S$ 表示

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224127432.png" alt="image-20241201224127432" style="zoom:50%;" />

### 求解方法

#### 找出最优解的性质，并刻画其结构特征

$S\left[i\right]\left[j\right]=A\left[i\right]\left[j\right]+\max{\left(S\left[i+1\right]\left[j\right],S\left[i+1\right]\left[j+1\right]\right)}$

自底逆向移动到达各位置的路径上的最大数字和

#### 最优值的递归定义

$S\left[i\right]\left[j\right]=\left\lbrace\begin{aligned}&A[i][j]&i=n\\\\&A[i][j]+\min{S[i+1][j],S[i+1][j+1]}&1\le i<n\end{aligned}\right.$

### 代码实现

```java
public List<Object> dp(int[][] a) {
    int[][] s = new int[a.length][a.length];
    int[][] route = new int[a.length][a.length];
    System.arraycopy(a[a.length - 1], 0, s[a.length - 1], 0, a.length);
    for (int i = a.length - 2; i >= 0; i--) {
        for (int j = 0; j < i + 1; j++) {
            if (s[i + 1][j] >= s[i + 1][j + 1]) {
                s[i][j] = a[i][j] + s[i + 1][j];
                route[i][j] = j;
            } else {
                s[i][j] = a[i][j] + s[i + 1][j + 1];
                route[i][j] = j + 1;
            }
        }
    }
    int[] result = new int[a.length];
    int temp = 0;
    for (int i = 0; i < a.length; i++) {
        result[i] = a[i][temp];
        temp = route[i][temp];
    }
    for (int i = 0; i < a.length / 2; i++) {
        temp = result[i];
        result[i] = result[a.length - 1 - i];
        result[a.length - 1 - i] = temp;
    }
    return new ArrayList<>() {{
        add(s[0][0]);
        add(result);
    }};
}
```

