# 算法设计与分析（6）——分支限界法

分支限界法的基本思想
分支限界法与回溯法的不同
求解目标
回溯法的求解目标是找出解空间树中满足约束条件的所有解（或一个最优解）
分支限界法的求解目标则是找出满足约束条件的一个解（或最优解）
搜索方式的不同
回溯法以深度优先的方式搜索解空间树而分支限界法则以广度优先或以最小耗费优先的方式搜索解空间树。
分支限界法基本思想
以广度优先或最小耗费（最大效益）优先的方式搜索问题的解空间树。
每个活结点只有一次机会成为扩展结点并一次性产生其所有儿子结点。
儿子结点中导致不可行解或非最优解的儿子结点被舍弃，其余儿子结点被加入活结点表中。如是最小耗费优先，活结点表需要重新排序。
此后从活结点表中取下一结点成为当前扩展结点，并重复上述结点扩展过程。这个过程一直持续到找到所需的解或活结点表为空时为止。
常见的两种分支限界法
队列式（FIFO）
分支限界法按照队列先进先出（FIFO）原则选取下一个结点为扩展结点
优先队列式
分支限界法按照优先队列中规定的优先级选取优先级最高的结点成为当前扩展结点。
装载问题
问题描述
有一批共个集装箱要装上2艘载重量分别为c_1和c_2的轮船
其中集装箱i的重量为w_i，且\sum_{i=1}^{n}w_i\lec_1+c_2
采用下面的策略可得到最优装载方案。
将第一艘轮船尽可能装满
将剩余集装箱装上第二艘轮船
队列式分支限界法
检测当前扩展结点的左儿子结点，可行入队
将其右儿子结点加入队列（右儿子结点一定可行）
舍弃当前扩展结点。
每层结点之后都加一个尾部标记-1，将活结点分层。
算法的改进（右子树加入剪枝条件）
上述算法中右子没有剪枝，效率较差
策略
设min是当前最优解；cur是当前扩展结点所相应的重量；remain是剩余集装箱的重量。则当cur+remain\lemin时，可将其右子树剪去
为确保右子树成功剪枝，算法每一次进入左子树的时候更新min的值。不要等待i=n时才去更新。
构造最优解
为在算法结束后能方便地构造出与最优值相应的最优解，可在每个结点处设置指向其父结点的指针，并设置左、右儿子标志。
代码实现
public static class Node {
    private final Node parent;
    private final boolean loaded;
    private final int weight;
    public Node(Node parent, boolean loaded, int weight) {
        this.parent = parent;
        this.loaded = loaded;
        this.weight = weight;
    }
}
public int queue() {
    Queue<Node> queue = new LinkedList<>();
    int i = 0;
    queue.add(new Node(null, false, 0));
    queue.add(new Node(null, false, -1));
    int remain = 0;
    for (int weight : weights) {
        remain += weight;
    }
    while (!queue.isEmpty()) {
        Node cur = queue.poll();
        if (cur.weight == -1 && i < weights.length) {
            queue.add(cur);
            remain -= weights[i];
            i++;
            continue;
        }
        if (i < weights.length) {
            if (cur.weight + weights[i] <= capacity) {
                max = Math.max(max, cur.weight + weights[i]);
                queue.offer(new Node(cur, true, cur.weight + weights[i]));
            }
            if (cur.weight + remain > max) {
                queue.offer(new Node(cur, false, cur.weight));
            }
        } else {
            if (cur.weight >= 0 && cur.weight <= capacity) {
                if (max == cur.weight) {
                    Node temp = cur;
                    for (int j = i - 1; j >= 0; j--) {
                        loaded[j] = temp.loaded;
                        temp = temp.parent;
                    }
                }
            }
        }
    }
    return max;
}
优先队列式分支限界法
用最大优先队列存储活结点表（大顶堆）
活结点x的优先级
根到结点x的路径相应的载重量+剩余集装箱重量之和
优先队列中优先级最大的活结点成为下一个扩展结点。
以结点x为根的子树中所有结点相应的路径的载重量不会超过x的优先级。
叶结点所相应的载重量与其优先级相同。
因此一旦优先队列中有一个叶结点成为当前扩展结点，则可以断言该叶结点所相应的解即为最优解。此时可终止算法
注意算法中叶子结点要进队列
代码实现
public int priority() {
    PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> b.weight - a.weight);
    int i = 0;
    pq.add(new Node(null, false, 0));
    int remain = 0;
    for (int weight : weights) {
        remain += weight;
    }
    while (!pq.isEmpty()) {
        Node cur = pq.poll();
        if (i < weights.length) {
            if (cur.weight + weights[i] <= capacity) {
                max = Math.max(max, cur.weight + weights[i]);
                pq.offer(new Node(cur, true, cur.weight + weights[i]));
            }
            if (cur.weight + remain > max) {
                pq.offer(new Node(cur, false, cur.weight));
            }
        } else {
            if (cur.weight >= 0 && cur.weight <= capacity) {
                if (max == cur.weight) {
                    Node temp = cur;
                    for (int j = i - 1; j >= 0; j--) {
                        loaded[j] = temp.loaded;
                        temp = temp.parent;
                    }
                }
            }
        }
        if (cur.weight == -1 && i < weights.length) {
            remain -= weights[i];
            i++;
        }
    }
    return max;
}
布线问题
问题描述

代码实现
public static class Point {
    private int x;
    private int y;
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
}
private boolean in(int x, int y) {
    return x >= 0 && x < matrix.length && y >= 0 && y < matrix[x].length;
}
private void getRoute() {
    route = new Point[matrix[end.x][end.y] + 1];
    Point cur = new Point(end.x, end.y);
    int[] xRange = new int[]{-1, 0, 1, 0};
    int[] yRange = new int[]{0, 1, 0, -1};
    while (matrix[cur.x][cur.y] != 0) {
        route[matrix[cur.x][cur.y]] = new Point(cur.x, cur.y);
        for (int i = 0; i < xRange.length; i++) {
            int curX = cur.x + xRange[i];
            int curY = cur.y + yRange[i];
            if (in(curX, curY) && matrix[curX][curY] == matrix[cur.x][cur.y] - 1) {
                cur.x = curX;
                cur.y = curY;
                break;
            }
        }
    }
    route[0] = new Point(start.x, start.y);
}
public int queue() {
    Queue<Point> queue = new LinkedList<>();
    queue.add(start);
    int[] xRange = new int[]{-1, 0, 1, 0};
    int[] yRange = new int[]{0, 1, 0, -1};
    while (!queue.isEmpty()) {
        Point point = queue.poll();
        int cur = matrix[point.x][point.y];
        for (int i = 0; i < xRange.length; i++) {
            int curX = point.x + xRange[i];
            int curY = point.y + yRange[i];
            if (in(curX, curY) && matrix[curX][curY] > cur) {
                matrix[curX][curY] = cur + 1;
                if (end.x == curX && end.y == curY) {
                    getRoute();
                    return cur + 1;
                }
                queue.add(new Point(curX, curY));
            }
        }
    }
    return -1;
}
时间复杂度
算法O\left(mn\right)
计算最优解时O\left(L\right)，其中L是最短路径长度