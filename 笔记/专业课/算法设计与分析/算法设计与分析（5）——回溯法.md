# 算法设计与分析（5）——回溯法

## 回溯法

当需要找出问题的解集或者要求满足某些约束条件的最优解时，常使用回溯法

回溯法的基本方法就是搜索，是一种组织得井井有条的，能避免不必要搜索的穷举式搜索法。

这种方法适用于解一些组合数相当大的问题，如排列、子集。0-1 背包问题、$n$ 皇后安排问题等可以使用回溯法

回溯法在问题的解空间树中，按深度优先策略，从根结点出发搜索整个解空间树。

算法搜索至解空间树的任意一点时，先判断该结点是否包含问题的解。

- 如果不包含，跳过对该结点为根的子树的搜索，继续该结点兄弟结点的搜素
- 否则，进入该子树，继续按深度优先策略搜索。

### 一些概念

- 问题的解向量

    回溯法希望一个问题的解能够表示成一个 $n$ 元组 $\left(x_1,x_2,\cdots,x_n\right)$

- 显约束

    对分量 $x_i$ 的取值限定。

- 隐约束

    为满足问题的解而对不同分支施加的约束。

- 解空间

    对于问题的一个实例，解向量满足显式约束条件的所有n元组，构成了该实例的一个解空间

- 组织成一棵树——解空间树

- 扩展结点

    一个正在产生儿子的结点称为扩展结点

- 活结点

    一个自身已生成但其儿子还没有全部生成的结点称做活结点

- 死结点

    一个所有儿子已经产生的结点称做死结点

- 深度优先的问题状态生成法

    如果对一个扩展结点 $R$，一旦产生了它的一个儿子 $C$，就把 $C$ 当做新的扩展结点，$R$ 成为活结点。在完成对子树 $C$（以 $C$ 为根的子树）的穷尽搜索之后，将 $R$ 重新变成扩展结点，继续生成 $R$ 的下一个儿子（如果存在）。$R$ 的全部孩子结点产生完毕，$R$ 成为死结点。

- 宽度优先的问题状态生成法

    在一个扩展结点变成死结点之前，它一直是扩展结点

- 回溯法

    为了避免生成那些不可能产生最佳解的问题状态，要不断地利用剪枝函数来处死那些实际上不可能产生所需解或最优解的儿子结点，以减少问题的计算量。

- 具有剪枝函数的深度优先生成树法称为回溯法

## 回溯法的基本思想

针对所给问题，定义问题的解空间（所有可能的解集合）

确定易于搜索的解空间结构（树）

以深度优先方式搜索解空间，并在搜索过程中用剪枝函数避免无效搜索

常用剪枝函数

1. 用约束函数在扩展结点处剪去不满足约束的子树
2. 用限界函数剪去得不到最优解的子树

回溯法解题的一个显著特征是

- 在搜索过程中动态产生问题的解空间树，即边搜索边扩展分支。
- 不同于数据结构中树的深度遍历方法，先创建树，再深度遍历

在任何时刻，算法只保存从根结点到当前扩展结点的路径。

若解空间树中从根结点到叶结点的最长路径的长度为 $h\left(n\right)$，则回溯法所需的计算空间通常为 $O\left(h\left(n\right)\right)$。

显式地存储整个解空间则需要 $O\left(2^{h\left(n\right)}\right)$ 或 $O\left(h\left(n\right)!\right)$ 的内存空间。

## 递归回溯算法框架

回溯法对解空间作深度优先搜索，一般用递归算法实现回溯法。

```java
public void backtrack(int t) {
    if (t > n) {
        output(x);
    } else {
        for (int i = f(n, t); i <= g(n, t); i++) {
            x[t] = h(i);
            if (constraint(t) && bound(t)) {
                backtrack(t + 1);
            }
        }
    }
}
```

## 装载问题

### 装载问题

共 $n$ 个集装箱要装上 2 艘载重量分别为 $c_1$ 和 $c_2$ 的轮船，其中集装箱 $i$ 的重量为 $w_i$，$\sum_{i=1}^{n}w_i\le c_1+c_2$。装载问题要求确定是否有一个合理的装载方案可将这些集装箱装上这 2 艘轮船。如果有，找出一种装载方案

### 最优装载方案

1. 首先将第一艘轮船尽可能装满
2. 将剩余的集装箱装上第二艘轮船。

将第一艘轮船尽可能装满等价于选取全体集装箱的一个子集，使该子集中集装箱重量之和最大。
$$
max\sum_{i=1}^{n}{w_ix_i},\ \sum_{i=1}^{n}{w_ix_i}\le c_1,x_i\in\left\lbrace 0,1\right\rbrace,1\le i\le n
$$

### 代码实现

```java
public boolean backtrack() {
    int sum = 0;
    for (int weight : this.weights) {
        sum += weight;
    }
    backtrack(0, 0, new boolean[weights.length], sum, 1);
    sum = 0;
    for (int i = 0; i < this.weights.length; i++) {
        if (visited[i]) {
            loaded[i] = 1;
        } else {
            sum += this.weights[i];
        }
    }
    max = Integer.MIN_VALUE;
    backtrack(0, 0, new boolean[weights.length], sum, 2);
    for (int i = 0; i < this.weights.length; i++) {
        if (visited[i]) {
            loaded[i] = 2;
        }
        if (loaded[i] == 0) {
            return false;
        }
    }
    return true;
}
public void backtrack(int i, int curWeight, boolean[] x, int remain, int ship) {
    if (i >= weights.length) {
        if (curWeight > max) {
            max = curWeight;
            System.arraycopy(x, 0, visited, 0, x.length);
            return;
        }
    }
    if (loaded[i] == 0 && curWeight + weights[i] <= capacity[ship - 1]) {
        x[i] = true;
        backtrack(i + 1, curWeight + weights[i], x, remain - weights[i], ship);
    }
    if (curWeight + remain - weights[i] > max) {
        x[i] = false;
        backtrack(i + 1, curWeight, x, remain - weights[i], ship);
    }
}
```

### 时间复杂度

用回溯法解装载问题的时间复杂性是 $O\left(2^n\right)$。在某些情况下该算法优于动态规划算法。

#### 回溯法算法如何计算其复杂性呢？

1. 计算出解空间树中除叶子层之外的结点总数 $f\left(n\right)$
2. 每个非叶子结点扩展出其下一层的所有分支的时间复杂性 $g\left(n\right)$
3. 复杂性为 $O\left(f\left(n\right)\times g\left(n\right)\right)$​

$f\left(n\right)=2n-1$，$g\left(n\right)=O\left(1\right)$，因此其时间复杂性为 $O\left(2^n\right)$

## 批处理作业调度

$n$ 个作业集合 $\left\lbrace 1,2,\cdots,n\right\rbrace$。每个作业先由机器 1 处理，再由机器 2 处理。作业 $i$ 需要机器 $j$ 的处理时间为 $M_{ij}$。

对于一个确定的作业调度，设 $F_{ij}$ 是作业 $i$ 在机器 $j$ 上完成的具体时间。

所有作业在机器 2 上完成的具体时间（时刻）之和称为该作业调度的完成时间和。

### 要求

对于给定的 $n$ 个作业，制定最佳作业调度方案（一个排列），使其完成时间和达到最小。

### 代码实现

```java
public int backtrack() {
    int[] curArray = new int[matrix.length];
    for (int i = 0; i < matrix.length; i++) {
        curArray[i] = i;
    }
    backtrack(0, 0, 0, new int[matrix.length], curArray);
    return minFinish;
}
public void backtrack(int i, int finish, int finishA, int[] finishB, int[] curArray) {
    if (i >= matrix.length) {
        if (minFinish > finish) {
            minFinish = finish;
            System.arraycopy(curArray, 0, array, 0, matrix.length);
        }
        return;
    }
    for (int j = i; j < matrix.length; j++) {
        finishA += matrix[curArray[j]][0];
        finishB[i] = (Math.max(i - 1 >= 0 ? finishB[i - 1] : 0, finishA)) + matrix[curArray[j]][1];
        finish += finishB[i];
        if (finish < minFinish) {
            int temp = curArray[i];
            curArray[i] = curArray[j];
            curArray[j] = temp;
            backtrack(i + 1, finish, finishA, finishB, curArray);
            temp = curArray[i];
            curArray[i] = curArray[j];
            curArray[j] = temp;
        }
        finishA -= matrix[curArray[j]][0];
        finish -= finishB[i];
    }
}
```

### 时间复杂度

$O\left(n!\right)$

## 符号三角形问题

### 问题描述

由“+”和“-”组成的符号三角形，2 个同号下面都是“+”，2 个异号下面都是“-”

符号三角形的第一行有 $n$ 个符号。符号三角形问题要求对于给定的 $n$​，计算有多少个不同的符号三角形，使其所含的“+”和“-”的个数相同。

<img src="http://public.file.lvshuhuai.cn/images\image-20241209123937053.png" alt="image-20241209123937053" style="zoom:50%;" />

### 解向量

用 $n$ 元组 $x\left[0:n-1\right]$ 表示符号三角形的第一行。

### 可行性约束函数

当前符号三角形所包含的“+”个数与“-”个数均不超过 $\frac{n\times\left(n+1\right)}{4}=half$。

### 无解的判断

$\frac{n\times\left(n+1\right)}{2}$ 为奇数

### 代码实现

```java
public int backtrack() {
    int half = n * (n + 1) / 2;
    if (half % 2 == 1) {
        sum = 0;
        return sum;
    }
    backtrack(0, half / 2, 0);
    return sum;
}
public void backtrack(int t, int half, int count) {
    if (count > half || t * (t + 1) / 2 - count > half) {
        return;
    }
    if (t >= n) {
        sum++;
        char[][] cur = new char[n][n];
        for (int i = 0; i < n; i++) {
            System.arraycopy(drawing[i], 0, cur[i], 0, n);
        }
        results.add(cur);
        return;
    }
    char[] symbol = new char[]{'+', '-'};
    for (int i = 0; i < 2; i++) {
        drawing[0][t] = symbol[i];
        count += i;
        for (int j = 1; j <= t; j++) {
            int cur = drawing[j - 1][t - j] == drawing[j - 1][t - j + 1] ? 0 : 1;
            drawing[j][t - j] = symbol[cur];
            count += cur;
        }
        backtrack(t + 1, half, count);
        for (int j = 1; j <= t; j++) {
            count -= drawing[j][t - j] == '+' ? 0 : 1;
        }
        count -= i;
    }
}
```

### 复杂度分析

计算可行性约束需要 $O\left(n\right)$ 时间，在最坏情况下有 $O\left(2^n\right)$ 个结点需要计算可行性约束，故解符号三角形问题的回溯算法所需的计算时间为 $O\left(n2^n\right)$。