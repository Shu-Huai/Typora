# 算法设计与分析（4）——贪心算法

## 何谓贪心？

追求利益最大化或代价（耗费）最小化。

现实生活中人们经常用贪心思想解决实际问题

## 贪心算法

贪心算法就是按照某种策略（方法）一步步地做选择，每一步总是作出在当前看来最好的选择（局部最优），不从整体最优考虑。

找零钱的方法就是贪心算法

贪心算法又称作贪心选择算法

贪心算法对有些问题可以快速获得整体最优解。

对有些问题虽不能得到整体最优解，却是近似最优解。

## 活动安排算法

### 问题描述

$n$ 个需要使用某个公共资源的活动。

$S=\left\lbrace a_1,\cdots,a_n\right\rbrace$

$a_i$ 在半开区间 $\left[s_i,f_i\right)$ 使用资源，其中 $s_i=开始时间$，$f_i=结束时间$

目标：安排最大可能的相容的活动集合

### 贪心算法

找到一种贪心策略，也就是活动的选择方法，按该方法经过一次次的选择，找出相容的最多的活动。
找活动结束时间最早的

### 代码实现

```java
public int greedy() {
    Arrays.sort(activities, Comparator.comparingInt(o -> o.end));
    int j = 0;
    for (int i = 0; i < activities.length; i++) {
        if (i == 0 || activities[i].start >= activities[j].end) {
            activities[i].selected = true;
            j = i;
            count++;
        }
    }
    return count;
}
```

### 时间复杂度

$O\left(n\log{n}\right)$

## 贪心算法的基本要素

对于一个具体的问题，是否可用贪心算法得到问题的最优解呢？

### 问题应具有 2 个重要的性质

1. 贪心选择性质

   - 贪心选择性质是指所求问题的整体最优解，可以通过一系列局部最优的选择，即贪心选择来达到。

   - 贪心选择性质证明方法

     一步步的贪心选择（局部最优）最终导致问题的整体最优解。

2. 最优子结构性质
   - 当一个问题的最优解包含其子问题的最优解时，称此问题具有最优子结构性质
   - 因为最优解对应最优值，所以通常证明问题的最优值包含其子问题的最优值。

### 贪心算法与动态规划算法的差异

- 性质相同点

  贪心算法和动态规划算法都要求问题具有最优子结构性质

- 性质不同点

  贪心算法要求问题具有贪心选择性质，动态规划算法则不要求。

- 计算方式的不同

  动态规划算法通常以自底向上的方式解各子问题

  贪心算法以自顶往下的方式进行，每做一次贪心选择就将问题变为规模更小的子问题。

### 0-1 背包问题与背包问题

- 0-1 背包问题

  给定 $n$ 种物品和一个背包。物品 $i$ 的重量是 $w_i$，其价值为 $V_i$，背包的容量为 $c$。应如何选择装入背包的物品，使得装入背包中物品的总价值最大？

- 背包问题

  与 0-1 背包问题类似，所不同的是在选择物品 $i$ 装入背包时，可以选择物品 $i$ 的一部分，而不一定要全部装入背包，$1\le i\le n$。

这 2 类问题都具有最优子结构性质，极为相似

背包问题可以用贪心算法求最优解

0-1 背包问题却不能用贪心算法求最优解

### 用贪心算法解背包问题

#### 贪心策略

每次选择单位重量价值最高的物品装入背包

#### 基本步骤

1. 计算每种物品单位重量的价值 $\frac{v_i}{w_i}$，按单位重量的价值从大到小将 $n$ 种物品排序。
2. 以排序后的次序依次将物品装入背包。直至全部物品都装入或者因背包容量不足不能装入为止。
3. 如果背包尚有容量，将最后不能完全装入物品切割一部分装满背包
4. 算法结束。

#### 代码实现

```java
public double greedy() {
    Arrays.sort(items, (o1, o2) -> Double.compare(o2.value / o2.weight, o1.value / o1.weight));
    double temp = capacity;
    for (Item item : items) {
        if (item.weight > temp) {
            item.selected = temp / item.weight;
            result += item.selected * item.value;
            break;
        }
        item.selected = 1;
        temp -= item.weight;
        result += item.value;
    }
    return result;
}
```

#### 时间复杂度

$O\left(n\log{n}\right)$

## 最优装载

### 问题描述

有一批集装箱要装上一艘载重量为c的轮船。其中集装箱的重量为w_i。最优装载问题要求确定在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船

### 确定贪心策略

采用重量最轻者先装的贪心选择策略，可产生该问题的最优解。

### 贪心选择性质

设集装箱依其重量从小到大排序，$\left(x_1,x_2,\cdots,x_n\right)$ 是其最优解，$x_i=\left\lbrace 0,1\right\rbrace$，设 $x_k$ 是第一个等于 1 的

如 $k=1$，则满足贪心选择性质

如 $k\ne 1$，用 $x_1$ 替换 $x_k$，构造的新解同原解最优值相同，故也是最优解，满足贪心选择性质。

该证明方法只证明了任何一个最优解都可以转换为第一个集装箱上船的最优解（满足贪心策略）。此方法对子问题同样有效，因此可将一个普通最优解转化为满足贪心策略的最优解

### 最优子结构性质

最优装载问题具有最优子结构性质。设 1 至 $n$ 个集装箱装上船的最大数量为 $T\left(1,n,w\right)$

则 $T\left(1,n,w\right)=1+T\left(2,n,w-w_1\right)$

因 $T\left(1,n,w\right)$ 是最优值，则 $T\left(2,n,w-w_1\right)$ 一定是最优值。反证法证明之。

### 代码实现

```java
public int greedy() {
    Arrays.sort(weights);
    int temp = capacity;
    for (int weight : weights) {
        if (weight > temp) {
            break;
        }
        temp -= weight;
        count++;
    }
    return count;
}
```

### 时间复杂度

$O\left(n\log{n}\right)$

## 哈夫曼编码

哈夫曼编码是广泛应用于数据文件压缩的十分有效编码方法，是一种变长编码方法

### 前缀码（Prefix codehuffman）编码

给定一个序列的集合，若不存在一个序列是另一个序列的前缀，则该序列集合称为前缀码。

### 平均比特数（平均编码长度）

$B\left(T\right)=\sum_{c\in C}{d_T\left(c\right)f\left(c\right)}$

- $d_T\left(c\right)$：叶子 $c$ 在 $T$ 中的深度（编码长度）
- $f(c)$：$c$ 在文件中出现的频度
- $C$：字符集
- $B\left(T\right)$：平均比特数

### 贪心策略

每次选择两个最低发生频率的结点构造一颗子树的根结点。并把产生的子树的根结点再插入到优先队列中

### 贪心选择性质

设 $C$ 为一字母表，其中每个字符 $c\in C$ 具有频率 $f\left[c\right]$。设 $x$ 和 $y$ 为 $C$ 中具有最低频率的两个字符，则存在 $C$ 的一种最优前缀编码，其中 $x$ 和 $y$ 的编码长度相同但最后一位不同。

<img src="http://public.file.lvshuhuai.cn/images\image-20241207144617663.png" alt="image-20241207144617663" style="zoom:50%;" />

$B\left(T\right)-B\left(T^\prime\right)=d_T\left(b\right)\left(f\left(b\right)-f\left(x\right)\right)+d_T\left(x\right)\left(f\left(x\right)-f\left(b\right)\right)=\ \left(f\left(b\right)-f\left(x\right)\right)\left(d_T\left(b\right)-d_T\left(x\right)\right)\ge 0$

$B\left(T^\prime\right)-B\left(T^{\prime\prime}\right)=\cdots=\left(f\left(c\right)-f\left(y\right)\right)\left(d_{T^\prime}\left(c\right)-d_{T^\prime}\left(y\right)\right)\ge 0$

由此推出 $B\left(T\right)\ge B\left(T^\prime\right)\ge B\left(T^{\prime\prime}\right)$

因为 $T$ 是最优解，因此只有 $B\left(T\right)=B\left(T^{\prime\prime}\right)$ 成立

推出结论：$T''$ 是最优哈夫曼编码树，且发生频率最低的两个字符在哈夫曼树的最低层，是同一个父结点的孩子结点，编码在最后一位不同。从而可知该贪心选择法可一步步构造出最优解

### 最优子结构性质

设 $T$ 为一种最优前缀编码树，字母表为 $C$

两个为兄弟叶结点的字符 $x$ 和 $y$，$z$ 为它们的父结点。

若认为 $z$ 是一个频率为 $f\left[z\right]=f\left[x\right]+f\left[y\right]$ 的字符

树 $T\prime=T-\left\lbrace x,y\right\rbrace$ 就表示了字母表 $C^\prime=C-\left\lbrace x,y\right\rbrace\cup\left\lbrace z\right\rbrace$上的一种最优前缀编码。

可得 $B\left(T\right)=B\left(T^\prime\right)+f\left(x\right)+f\left(y\right)$

用反证法可以证明 $B\left(T^\prime\right)$ 一定是最优值，故 $T^\prime$ 也是最优前缀编码子树.

### 代码实现

```java
private void buildTree() {
    PriorityQueue<Tree> minHeap = new PriorityQueue<>(Comparator.comparingInt(o -> o.weight));
    for (Char aChar : chars) {
        Tree temp = new Tree();
        temp.root = new TreeNode();
        temp.root.val = aChar.val;
        temp.weight = aChar.weight;
        minHeap.offer(temp);
    }
    while (minHeap.size() > 1) {
        Tree t1 = minHeap.poll();
        Tree t2 = minHeap.poll();
        Tree newTree = new Tree();
        newTree.root = new TreeNode();
        newTree.root.left = t1.root;
        assert t2 != null;
        newTree.root.right = t2.root;
        newTree.weight = t1.weight + t2.weight;
        minHeap.offer(newTree);
    }
    tree = minHeap.poll();
}
public int greedy() {
    buildTree();
    int totalWeight = 0;
    for (Char aChar : chars) {
        aChar.code = getCharCode(aChar.val);
        totalWeight += aChar.weight * aChar.code.length();
    }
    return totalWeight;
}
public String getCharCode(char c) {
    StringBuilder code = new StringBuilder();
    getCharCode(tree.root, c, code);
    return code.reverse().toString();
}
private boolean getCharCode(TreeNode node, char c, StringBuilder code) {
    if (node == null) {
        return false;
    }
    if (node.val == c && node.left == null && node.right == null) {
        return true;
    }
    if (getCharCode(node.left, c, code)) {
        code.append('0');
        return true;
    }
    if (getCharCode(node.right, c, code)) {
        code.append('1');
        return true;
    }
    return false;
}
```

