# 算法设计与分析（3）——动态规划

## 算法总体思想

动态规划算法与分治法类似，其基本思想也是将待求解问题分解成若干个子问题

但是经分解得到的子问题往往不是互相独立的。不同子问题的数目常常只有多项式量级。在用分治法求解时，有些子问题被重复计算了许多次

如果能够保存已解决的子问题的答案，而在需要时再找出已求得的答案，就可以避免大量重复计算，从而得到多项式时间算法。

## 动态规划基本步骤

1. 找出最优解的性质，并刻划其结构特征（最优子结构性质）
2. 递归地定义最优值。
3. 以自底向上的方式计算出最优值
4. 根据计算最优值时得到的信息，构造最优解

## 矩阵连乘问题

### 问题叙述

给定 $n$ 个矩阵 $A_1,A_2,\cdots,A_n$，其中，$A_i$ 与 $A_{i+1}$ 是可乘的，$i=1,2,\cdots,n-1$，现要计算出这 $n$ 个矩阵的连乘积 $A_1A_2\cdots A_n$。

矩阵连乘问题：确定一种运算次序，使总的运算次数达到最少。

#### 矩阵乘法

$A_{m\times k}=(a_{ij}),B_{k\times n}=(b_{ij}),C_{m\times n}=(c_{ij}),c_{ij}=\sum_{t=1}^{k}{a_{it}b_{tj}}$

计算 $C$：每个元素需 $k$ 次乘法，$k-1$ 次加法
$C$ 有 $mn$ 个元素：计算 $C$，需 $mnk$ 次乘法，$mn\left(k-1\right)$ 次加法

矩阵连乘方法数与添括号方式数一一对应

完全加括号的矩阵连乘积可递归地定义为

1. 单个矩阵是完全加括号的；
2. 若矩阵连乘积A是完全加括号的，则 $A$ 可表示为 2 个完全加括号的矩阵连乘积B和C的乘积并加括号，即 $A=\left(BC\right)$

### 算法分析

#### 穷举法

列举所有可能的计算次序，并计算出每一种计算次序相应需要的数乘次数，从中找出一种数乘次数最少的计算次序

$n$ 个矩阵的连乘积，设不同的计算次序为 $P\left(n\right)$。因每种加括号方式都可以分解为两个子矩阵的括号问题：$\left(A_1\cdots A_k\right)\left(A_{k+1}\cdots A_n\right)$，故 $P\left(n\right)$ 的递推式如下：

$P(n)=\left\lbrace\begin{aligned}&1&n=1\\\\&\sum_{k=1}^{n-1}{P(k)P(n-k)}&n>1\end{aligned}\right.\Rightarrow P(n)=\Omega(\frac{4^{n-1}}{(n-1)^{\frac{3}{2}}})$

#### 动态规划

##### 首先分析最优解的结构

将矩阵连乘积 $A_iA_{i+1}\cdots A_j$ 简记为 $A\left[i:j\right]$，这里 $i\le j$

考察计算 $A\left[i:j\right]$ 的最优计算次序，设这个计算次序在矩阵 $A_k$ 和 $A_{k+1}$ 之间将矩阵链断开，$i\le k<j$，则其相应完全加括号方式为$\left(A_iA_{i+1}\cdots A_j\right)=\left(\left(A_iA_{i+1}\cdots A_k\right)\left(A_{k+1}A_{k+2}\cdots A_j\right)\right)$

特征：计算 $A\left[i:j\right]$ 的最优次序所包含的计算矩阵子链 $A\left[i:k\right]$ 和 $A\left[k+1:j\right]$ 的次序也是最优的

- $m\left[i,j\right]$ 表示 $A\left[i:j\right]$ 的计算量
- $A\left[i:k\right]$ 的计算量为 $m\left[i,k\right]$
- $A\left[k+1:j\right]$ 的计算量为 $m\left[k+1,j\right]$
- 因此：$m\left[i,j\right]=m\left[i,k\right]+m\left[k+1,j\right]+p_{i-1}p_kp_j$
- 用反证法可证明，$m\left[i,j\right]$ 是最优值，则 $m\left[i,k\right]$，$m\left[k+1,j\right]$ 一定也是最优值
- 这里 $A_i$ 的维数为 $p_{i-1}\times p_i$

矩阵连乘计算次序问题的最优解包含着其子问题的最优解。这种性质称为最优子结构性质，可用动态规划算法求解的显著特征

##### 建立递归关系

设计算 $A\left[i:j\right],1\le i\le j\le n$所需的最少数乘次数 $m\left[i,j\right]$，则原问题的最优值为 $m\left[1,n\right]$

当 $i=j$ 时，$A[i:j]=A_i$, 因此 $m\left[i,i\right]=0,i=1,2\cdots,n$

当 $i<j$ 时，$m\left[i,j\right]=m\left[i,k\right]+m\left[k+1,j\right]+p_{i-1}p_kp_j$，这里 $A_i$ 的维数为 $p_{i-1}\times p_i$

$m\left[i,j\right]=\left\lbrace\begin{aligned}&0&i=j\\\\&\min_{i\le k<j}{m[i,k]+m[k+1,j]+p_{i-1}p_kp_j}&i<j\end{aligned}\right.$

$k$ 的位置只有 $j-i$ 种可能

##### 以自底向上的方式求最优值

对于 $1\le i\le j\le n$ 不同的有序对 $\left(i,j\right)$ 对应于不同的子问题。

因此，不同子问题的个数共有：$\binom{n}{2}=\left(n^2\right)$

用动态规划算法解此问题，可依据其递归式以自底向上的方式进行计算。

保存已解决的子问题答案。每个子问题只计算一次，需要时只要查一下子问题的结果，避免大量的重复计算，最终得到多项式时间的算法

##### 代码实现

```java
public List<Object> min(int[] p) {
    int[][] m = new int[p.length][p.length];
    int[][] s = new int[p.length][p.length];
    for (int i = 1; i < p.length; i++) {
        m[i][i] = 0;
    }
    for (int r = 2; r < p.length; r++) {
        for (int i = 1; i + r - 1 < p.length; i++) {
            int j = i + r - 1;
            int min = Integer.MAX_VALUE;
            for (int k = i; k < j; k++) {
                int t = m[i][k] + m[k + 1][j] + p[i - 1] * p[k] * p[j];
                if (t < min) {
                    min = t;
                    s[i][j] = k;
                }
            }
            m[i][j] = min;
        }
    }
    Queue<int[]> q = new LinkedList<>();
    Stack<String> stack = new Stack<>();
    q.offer(new int[]{1, p.length - 1});
    while (!q.isEmpty()) {
        int[] cur = q.poll();
        if (cur[0] == cur[1]) {
            stack.push(" " + cur[0] + " ");
            continue;
        }
        int k = s[cur[0]][cur[1]];
        q.offer(new int[]{cur[0], k});
        q.offer(new int[]{k + 1, cur[1]});
    }
    while (stack.size() > 1) {
        String first = stack.pop();
        String second = stack.pop();
        int firstNum = getNum(first);
        int secondNum = getNum(second);
        if (firstNum > secondNum) {
            String temp = first;
            first = second;
            second = temp;
        }
        String cur = "(" + first + second + ")";
        stack.push(cur);
    }
    return new ArrayList<>() {{
        add(m[1][p.length - 1]);
        add(stack.pop());
    }};
}
private int getNum(String str) {
    for (int i = 0; i < str.length(); i++) {
        if (str.charAt(i) != '(' && str.charAt(i) != ' ') {
            int j = i + 1;
            for (; j < str.length(); j++) {
                if (str.charAt(j) == ')' || str.charAt(j) == ' ') {
                    return Integer.parseInt(str.substring(i, j));
                }
            }
            if (j == str.length()) {
                return Integer.parseInt(str.substring(i, j));
            }
        }
    }
    return 0;
}
```

##### 复杂度

算法主要计算量取决于算法中子问题的数量，已知为 $O\left(n^2\right)$，求每个子问题的最优值的时间复杂性 $O\left(n\right)$（即 $k$ 控制循环次数最大值），因此算法的计算时间上界 $O\left(n^3\right)$。

算法所占用的辅助空间显然为 $O\left(n^2\right)$。

## 动态规划算法的基本要素

### 最优子结构

矩阵连乘计算次序问题的最优解包含着其子问题的最优解。此称为最优子结构性质。最优子结构是可用动态规划算法求解的前提。

问题的最优子结构性质证明

- 先假设由原问题的最优解导出的子问题的解不是最优的，再设法证明在这假设下可构造出比原问题最优解更好的解导致矛盾。

利用问题最优子结构性质，以自底向上的方式通过子问题的最优解逐步构造出整个问题的最优解。

### 重叠子问题

在用递归算法自顶向下解问题时，每次产生的子问题并不总是新问题，有些子问题被反复计算多次。这种性质称为子问题的重叠性质

### 备忘录方法

备忘录方法与直接递归方法的控制结构相同

区别

- 备忘录方法为每个求解过的子问题建立了备忘录
- 求解一个子问题时先检查是否已有答案，避免重复求解

### 动态规划算法的特点

- 阶段性
  - 计算最优值是分阶段进行的
  - 如矩阵连乘问题
    1. 先计算所有只有一个矩阵的情况
    2. 再计算所有二个相邻矩阵连乘的情况
    3. 再计算所有三个相邻矩阵连乘的情况
    4. ⋯
    5. 最后计算 $n$ 个矩阵连乘的情况
- 无后向性
  - 是指已经计算出的子问题的答案不能再更改
  - 如 Dijkstra 算法是有后向性的例子（用贪心算法解决的问题）

## 数字塔问题

自塔顶可沿箭头所示方向移动到底层，问如何移动使得路径上的数字和最大？其数字和是多少？

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224041277.png" alt="image-20241201224041277" style="zoom:50%;" />

### 存储问题

数字塔的矩阵 $A$ 表示

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224107610.png" alt="image-20241201224107610" style="zoom:50%;" />

数字和的矩阵 $S$ 表示

<img src="http://public.file.lvshuhuai.cn/images\image-20241201224127432.png" alt="image-20241201224127432" style="zoom:50%;" />

### 求解方法

#### 找出最优解的性质，并刻画其结构特征

$S\left[i\right]\left[j\right]=A\left[i\right]\left[j\right]+\max{\left(S\left[i+1\right]\left[j\right],S\left[i+1\right]\left[j+1\right]\right)}$

自底逆向移动到达各位置的路径上的最大数字和

#### 最优值的递归定义

$S\left[i\right]\left[j\right]=\left\lbrace\begin{aligned}&A[i][j]&i=n\\\\&A[i][j]+\min{S[i+1][j],S[i+1][j+1]}&1\le i<n\end{aligned}\right.$

### 代码实现

```java
public List<Object> dp(int[][] a) {
    int[][] s = new int[a.length][a.length];
    int[][] route = new int[a.length][a.length];
    System.arraycopy(a[a.length - 1], 0, s[a.length - 1], 0, a.length);
    for (int i = a.length - 2; i >= 0; i--) {
        for (int j = 0; j < i + 1; j++) {
            if (s[i + 1][j] >= s[i + 1][j + 1]) {
                s[i][j] = a[i][j] + s[i + 1][j];
                route[i][j] = j;
            } else {
                s[i][j] = a[i][j] + s[i + 1][j + 1];
                route[i][j] = j + 1;
            }
        }
    }
    int[] result = new int[a.length];
    int temp = 0;
    for (int i = 0; i < a.length; i++) {
        result[i] = a[i][temp];
        temp = route[i][temp];
    }
    for (int i = 0; i < a.length / 2; i++) {
        temp = result[i];
        result[i] = result[a.length - 1 - i];
        result[a.length - 1 - i] = temp;
    }
    return new ArrayList<>() {{
        add(s[0][0]);
        add(result);
    }};
}
```

## 最长公共子序列

### 问题描述

若给定序列 $X=\left\lbrace x_1,x_2,\cdots,x_m\right\rbrace$，则另一序列 $Z=\left\lbrace z_1,z_2,\cdots z_k\right\rbrace$ 是 $X$ 的子序列是指存在一个严格递增下标序列 $\left\lbrace i_1,i_2,\cdots,i_k\right\rbrace$，使得对于所有 $j=1,2,\cdots,k$ 有 $z_j=x_{ij}$。

如：序列 $Z=\left\lbrace B,C,D,B\right\rbrace$ 是序列 $X=\left\lbrace A,B,C,B,D,A,B\right\rbrace$ 的子序列，相应的递增下标序列为 $\left\lbrace 2,3,5,7\right\rbrace$。

给定 2 个序列 $X$ 和 $Y$，当另一序列 $Z$ 既是 $X$ 的子序列又是 $Y$ 的子序列时称 $Z$ 是序列 $X$ 和 $Y$ 的公共子序列。

给定 2 个序列 $X=\left\lbrace x_1,x_2,\cdots,x_m\right\rbrace$ 和 $Y=\left\lbrace y_1,y_2,\cdots,y_n\right\rbrace$，找 $X$ 和 $Y$ 的最长公共子序列。

### 最长公共子序列的结构

设序列 $X=\left\lbrace x_1,x_2,\cdots,x_m\right\rbrace$ 和 $Y=\left\lbrace y_1,y_2,\cdots,y_n\right\rbrace$ 的最长公共子序列为 $Z=\left\lbrace z_1,z_2,\cdots z_k\right\rbrace$，则

- 若 $x_m=y_n$，则 $z_k=x_m=y_n$，且 $Z-z_k$ 是 $X-x_m$ 和 $Y-y_n$ 的最长公共子序列。
- 若 $x_m\neq y_n$ 且 $z_k\neq x_m$，则 $Z$ 是 $X-x_m$ 和 $Y$ 的最长公共子序列。
- 若 $x_m\neq y_n$ 且 $z_k\neq y_n$，则 $Z$ 是 $X$ 和 $Y-y_n$ 的最长公共子序列。

由此可见，2 个序列的最长公共子序列包含了这 2 个序列的前缀的最长公共子序列。因此，最长公共子序列问题具有最优子结构性质。

### 最优值的递归定义

用 $c\left[i\right]\left[j\right]$记录序列的最长公共子序列的长度。其中 $X=\left\lbrace x_1,x_2,\cdots,x_i\right\rbrace,Y_j=\left\lbrace y_1,y_2,\cdots,y_j\right\rbrace$。

递归关系如下：
$c\left[i\right]\left[j\right]=\left\lbrace\begin{aligned}&0&i=0\lor j=0\\\\&c[i-1][j-1]+1&i,j>0;x_i=y_j\\\\&\max{c[i][j-1],c[i-1][j]}&i,j>0;x_i\neq y_j\end{aligned}\right.$

### 代码实现

```java
public String dp(String a, String b) {
    int[][] c = new int[a.length() + 1][b.length() + 1];
    for (int i = 0; i < a.length(); i++) {
        c[i][0] = 0;
    }
    for (int j = 0; j < b.length(); j++) {
        c[0][j] = 0;
    }
    for (int i = 1; i < a.length() + 1; i++) {
        for (int j = 1; j < b.length() + 1; j++) {
            if (a.charAt(i - 1) == b.charAt(j - 1)) {
                c[i][j] = c[i - 1][j - 1] + 1;
            } else {
                c[i][j] = Math.max(c[i - 1][j], c[i][j - 1]);
            }
        }
    }
    StringBuilder sb = new StringBuilder();
    int i = a.length();
    int j = b.length();
    while (i > 0 && j > 0) {
        if (c[i - 1][j] < c[i][j] && c[i][j - 1] < c[i][j]) {
            sb.append(a.charAt(i - 1));
            i--;
            j--;
        } else if (c[i - 1][j] == c[i][j]) {
            i--;
        } else if (c[i][j - 1] == c[i][j]) {
            j--;
        }
    }
    sb.reverse();
    return sb.toString();
}
```

### 时间复杂度

$O\left(mn\right)$

## 最大字段和问题

### 问题描述

给定由 $n$ 个整数（可能为负整数）组成的序列 $a_1,a_2,\cdots,a_n$，求该序列形如 $\sum_{k=i}^{j}{a_k}\left(1\le i\le j\le n\right)$ 的子段和的最大值。

当所有整数均为负整数时定义其最大子段和为 0。因此，所求的最优值为 $\max{\left(\max_{1\le i\le j\le n}{\sum_{k=i}^{j}{a_k}},0\right)}$

### 枚举法

对于任意一对下标 $i,j$，满足 $1\le i\le j\le n$，就是一个子段。

算法要考虑的是如何枚举所有这样的子段。

- $1\le i\le n$ 子段的起始位置（外循环控制）
- $i\le j\le n$ 子段的结束位置（内循环控制）

确定一个子段后，计算子段数字的累加和（第三重循环）

设计一个变量 $maxSum$ 记录最大子段和。

设计变量 $\left(begin,end\right)$ 记录最优子段起、止位置。

#### 代码实现

```java
public int[] enumeration(int[] nums) {
    int maxSum = Integer.MIN_VALUE;
    int begin = 0;
    int end = 0;
    for (int i = 0; i < nums.length; i++) {
        for (int j = i; j < nums.length; j++) {
            int sum = 0;
            for (int k = i; k <= j; k++) {
                sum += nums[k];
            }
            if (sum > maxSum) {
                maxSum = sum;
                begin = i;
                end = j;
            }
        }
    }
    return new int[]{begin, end};
}
```

#### 时间复杂度

$O\left(n^3\right)$

### 改进算法——递推

起始位置相同的子段和可以累加计算

#### 代码实现

```java
public int[] cleverEnumeration(int[] nums) {
    int maxSum = Integer.MIN_VALUE;
    int begin = 0;
    int end = 0;
    for (int i = 0; i < nums.length; i++) {
        int sum = 0;
        for (int j = i; j < nums.length; j++) {
            sum += nums[j];
            if (sum > maxSum) {
                maxSum = sum;
                begin = i;
                end = j;
            }
        }
    }
    return new int[]{begin, end};
}
```

#### 时间复杂度

$O\left(n^2\right)$

### 分治策略

将序列 $a\left[1:n\right]$ 分为长度相等的两段 $a\left[1:\frac{n}{2}\right]$ 和 $a\left[\frac{n}{2}+1:n\right]$，分别求出这两段的最大子段和 $S_1$，$S_2$

$S_1=\max_{1\le i\le j\le\frac{n}{2}}{\sum_{k=i}^{j}{a_k}}$

$S_2=\max_{\frac{n}{2}+1\le i\le j\le n}{\sum_{k=i}^{j}{a_k}}$

$a\left[1:n\right]$ 的最大子段和 $S$ 有三种可能

- $S=S_1$
- $S=S_2$
- $S=\sum_{k=i}^{j}{a_k},i\le\frac{n}{2},\frac{n}{2}+1\le j$ 

#### 代码实现

```java
public int[] recursive(int[] nums, int begin, int end) {
    if (begin == end) {
        return new int[]{begin, end};
    }
    int mid = (begin + end) / 2;
    int[] leftIndex = recursive(nums, begin, mid);
    int[] rightIndex = recursive(nums, mid + 1, end);
    int leftSum = sum(nums, leftIndex[0], leftIndex[1]);
    int rightSum = sum(nums, rightIndex[0], rightIndex[1]);
    int curBegin = 0;
    int temp = 0;
    int curLeftSum = Integer.MIN_VALUE;
    for (int i = mid; i >= begin; i--) {
        temp += nums[i];
        if (temp > curLeftSum) {
            curLeftSum = temp;
            curBegin = i;
        }
    }
    temp = 0;
    int curRightSum = Integer.MIN_VALUE;
    int curEnd = 0;
    for (int i = mid + 1; i <= end; i++) {
        temp += nums[i];
        if (temp > curRightSum) {
            curRightSum = temp;
            curEnd = i;
        }
    }
    int sum = curLeftSum + curRightSum;
    if (sum < leftSum || sum < rightSum) {
        if (leftSum > rightSum) {
            return leftIndex;
        }
        return rightIndex;
    }
    return new int[]{curBegin, curEnd};
}
public int[] recursive(int[] nums) {
    return recursive(nums, 0, nums.length - 1);
}
```

#### 时间复杂度

**递归方程**

$T\left(n\right)=\left\lbrace\begin{aligned}&O(1)&n=1\\\\&2T(\frac{n}{2})+O(n)&n>1\end{aligned}\right.$

**解得**

$T\left(n\right)=O\left(n\log{n}\right)$

### 动态规划

首先定义一个一般化的子问题，而且改变参数可表示任何一个子问题

提出：以 $a\left[i\right]$ 为子段结束元素的最大子段和问题，最大子段和用 $b\left[i\right]$ 表示

令 $1\le i\le n$，可代表任何一个子问题。

如果这些子问题的最大字段和都求出来，则 $\max_{0\le i\le n}{b\left[i\right]}$ 就是原问题答案

#### 找出最优解的性质，刻画其特征

以 $a\left[i\right]$ 为结尾的最大子段和 $b\left[j\right]$，包含了以 $a\left[i-1\right]$ 为结尾的最大子段和 $b\left[i-1\right]$（当 $b\left[i-1\right]>0$）

如果 $b\left[i-1\right]\le 0$，$b\left[j\right]=a\left[i\right]$，就没有子问题了

#### 递归定义最优值

设 $b\left[i\right]$ 是以 $a\left[i\right]$ 元素结尾的最大字段和

$s\left[j\right]$ 是获得 $b\left[i\right]$（最大字段和）子段起始位置

$b\left[i\right]=\left\lbrace\begin{aligned}&a_i&b_{i-1}\le 0\\\\&b_{i-1}+a_i&b_{i-1}>0\end{aligned}\right.$

#### 代码实现

```java
public int[] dp(int[] nums) {
    int max = Integer.MIN_VALUE;
    int b = -1;
    int begin = -1;
    int end = 0;
    int tempBegin = 0;
    for (int i = 0; i < nums.length; i++) {
        if (b < 0) {
            b = nums[i];
            tempBegin = i;
        } else {
            b += nums[i];
        }
        if (max < b) {
            max = b;
            begin = tempBegin;
            end = i;
        }
    }
    return new int[]{begin, end};
}
```

#### 时间复杂度

$T\left(n\right)=O\left(n\right)$

### 算法扩展

#### 最大子矩阵和

$m\times n$ 数字矩阵

求最大子矩阵和

**算法思想**

将矩阵第 $i$ 行到第 $j$ 行各元素按列求和得到一行（一维数组）

在该一维数组中找最大子段和。

所有可能的 $i,j$ 情况下得到的最大字段和为本题目的答案。

这里 $1\le i\le j\le m$

时间复杂度：$O\left(m^2n\right)$

**代码实现**

```java
public int[] dp(int[][] matrix) {
    int result = Integer.MIN_VALUE;
    int beginI = 0;
    int endI = 0;
    int beginJ = 0;
    int endJ = 0;
    for (int i = 0; i < matrix.length; i++) {
        int[] cur = new int[matrix[i].length];
        for (int j = i; j < matrix.length; j++) {
            for (int k = 0; k < matrix[j].length; k++) {
                cur[k] += matrix[j][k];
            }
            MaximumSubtotal ms = new MaximumSubtotal();
            int[] index = ms.dp(cur);
            int curSum = ms.sum(cur, index[0], index[1]);
            if (curSum > result) {
                result = curSum;
                beginI = i;
                endI = j;
                beginJ = index[0];
                endJ = index[1];
            }
        }
    }
    return new int[]{beginI, beginJ, endI, endJ};
}
public int sum(int[][] matrix, int beginI, int beginJ, int endI, int endJ) {
    int result = 0;
    for (int i = beginI; i <= endI; i++) {
        for (int j = beginJ; j <= endJ; j++) {
            result += matrix[i][j];
        }
    }
    return result;
}
```

#### 最大 $m$ 子段和问题

$n$ 个整数（可能为负数）组成的序列 $a_1,a_2,\cdots,a_n$，确定 $m$ 个不相交子段使这 $m$ 个子段和达到最大。$m=1$ 时就是前面介绍的最大子段和问题

**动态规划**

给出问题的一般化定义

前 $j$ 项最大 $i$ 子段和问题，且第 $i$ 子段包含 $a_j$ 元素，$1\le i\le m,i\le j\le n$，$b\left[i,j\right]$ 表示前 $j$ 项最大 $i$ 子段和，则问题的最优值 $\max_{m\le j\le n}{b\left(m,j\right)}$

**找出最优解性质，刻画其特征**

<img src="http://public.file.lvshuhuai.cn/images\image-20241202120155430.png" alt="image-20241202120155430" style="zoom:50%;" />

**递归定义**

$b\left[i,j\right]=\left\lbrace\begin{aligned}&0&i=0\lor j=0\\\\&0&1\le i\le m,j<i\lor j>n-m+i\\\\&\max{(b[i,j-1]+a[j],\max_{i-1\le t\le j-1}{b[i-1,t]+a[j]})}&1\le i\le m,i\le j\le n-m+i\end{aligned}\right.$

**算法设计**

<img src="http://public.file.lvshuhuai.cn/images\image-20241202120203226.png" alt="image-20241202120203226" style="zoom:50%;" />

**代码实现**

```java
public int dp(int[] nums, int m) {
    if (m > nums.length || m < 1) {
        return 0;
    }
    int[][] b = new int[m + 1][nums.length + 1];
    for (int i = 0; i <= m; i++) {
        for (int j = 0; j <= nums.length; j++) {
            b[i][j] = 0;
        }
    }
    for (int i = 1; i <= m; i++) {
        for (int j = i; j <= nums.length - m + i; j++) {
            b[i][j] = b[i][j - 1] + nums[j - 1];
            for (int k = i - 1; k < j; k++) {
                b[i][j] = Math.max(b[i][j], b[i - 1][k] + nums[j - 1]);
            }
        }
    }
    int sum = 0;
    for (int j = m; j <= nums.length; j++) {
        sum = Math.max(sum, b[m][j]);
    }
    return sum;
}
```

**复杂度**

- 时间复杂度 $T\left(n\right)=O\left(m\left(n-m\right)^2\right)$
- 空间复杂度 $S\left(n\right)=O\left(mn\right)$
