# HTTPS

## 什么是 HTTPS？

HTTPS（**HyperText Transfer Protocol Secure**）是一种安全的超文本传输协议，是 HTTP（超文本传输协议）的安全版。它用于在客户端（如浏览器）和服务器之间传输数据，并通过加密手段保护通信的机密性和完整性。

### HTTPS 的核心功能

- **数据加密**

    使用加密技术（如 TLS/SSL）对传输的数据进行加密，防止数据在传输过程中被窃听或篡改。

- **身份验证**

    HTTPS 使用数字证书（如 SSL 证书）验证服务器的身份，确保用户连接的是真实的服务器，而不是冒充的服务器。

- **数据完整性**

    确保数据在传输过程中不会被篡改。如果数据发生变化，接收方会检测到。

### HTTPS 的工作原理

HTTPS 主要通过以下几个步骤实现安全通信：

1. **客户端发起请求**

    浏览器向服务器发送请求，表明需要建立 HTTPS 连接。

2. **服务器响应并发送证书**

    服务器会发送一个包含公钥的数字证书（SSL 证书）给客户端，证书中包含服务器身份信息。

3. **验证证书**

    客户端验证服务器的证书是否合法，是否由受信任的证书颁发机构（CA）签发。

4. **建立加密会话**

    双方使用公钥加密生成会话密钥，用于后续的对称加密通信。

5. **安全数据传输**

    双方使用对称加密算法加密数据，确保数据安全传输。

### HTTPS 的优势

- **增强安全性**

    防止中间人攻击（MITM）和数据泄露。

- **提高可信度**

    用户可以通过 HTTPS 知道网站是经过验证的，增强信任感。

- **SEO 优势**

    搜索引擎（如 Google）会优先推荐 HTTPS 网站，有助于提升搜索排名。

### HTTPS 与 HTTP 的区别

| 特性         | HTTP                   | HTTPS                    |
| ------------ | ---------------------- | ------------------------ |
| **安全性**   | 不加密，易被窃听和篡改 | 加密，安全性高           |
| **端口号**   | 80                     | 443                      |
| **使用场景** | 不敏感数据的普通网站   | 涉及隐私或敏感信息的站点 |
| **速度**     | 更快（无加密负担）     | 略慢（加密有一定开销）   |

### HTTPS 的局限性

- **性能开销**

    HTTPS 需要更多的计算资源来进行加密和解密。

- **证书费用**

    虽然有免费证书（如 Let's Encrypt），但高级证书可能有费用。

- **复杂性增加**

    部署 HTTPS 需要一定的技术支持。

## 一些概念

### TLS/SSL

**TLS（Transport Layer Security）**和 **SSL（Secure Sockets Layer）**是用于在计算机网络中提供安全通信的加密协议。它们确保数据在传输过程中具有机密性、完整性和真实性。TLS 是 SSL 的后继版本，更安全和高效。

#### TLS 与 SSL 的关系

- **SSL（Secure Sockets Layer）**

    最早由 Netscape 开发的安全协议，最初版本是 1.0（未发布），随后发布了 SSL 2.0 和 SSL 3.0。

    > **注意**：SSL 已被弃用，现代网络通信主要使用 TLS。

- **TLS（Transport Layer Security）**

    是从 SSL 演化而来的协议。TLS 1.0 基于 SSL 3.0，但修复了许多安全漏洞，目前主流版本是 TLS 1.2 和 TLS 1.3。

| **协议版本** | **状态**       |
| ------------ | -------------- |
| SSL 2.0      | 已弃用         |
| SSL 3.0      | 已弃用         |
| TLS 1.0      | 不推荐使用     |
| TLS 1.1      | 不推荐使用     |
| TLS 1.2      | 当前主流版本   |
| TLS 1.3      | 最新版，最安全 |

#### TLS/SSL 的主要功能

1. **数据加密**
    - 通过对称加密算法保护通信内容。
    - 即使数据被截获，也无法被解读。
2. **身份验证**
    - 通过数字证书验证通信双方的身份，防止连接到假冒服务器。
3. **数据完整性**
    - 使用消息验证码（如 HMAC）检测数据是否被篡改。

#### TLS/SSL 的工作原理

1. **握手阶段（Handshake）**

    TLS/SSL 的核心是握手过程，建立安全连接：

    - **客户端发起请求**

        浏览器向服务器发送支持的加密算法和协议版本。

    - **服务器响应并发送证书**

        服务器返回公钥和数字证书（由 CA 签发）。

    - **验证证书**

        客户端检查证书的有效性（如过期时间、可信的 CA）。

    - **生成会话密钥**

        客户端使用服务器的公钥生成会话密钥，并加密发送给服务器。

    - **握手完成**

        双方使用对称加密的会话密钥进行后续通信。

2. **数据传输阶段**

    - 使用协商好的会话密钥进行对称加密，保护通信内容。

#### TLS/SSL 的常见加密技术

- **对称加密**

    双方使用同一个密钥加密和解密数据（如 AES）。

- **非对称加密**

    使用公钥加密，私钥解密（如 RSA）。

- **哈希算法**

    用于验证数据完整性（如 SHA-256）。

#### TLS/SSL 的优势

- **数据加密**

    防止敏感数据泄露。

- **身份验证**

    确保用户连接到真实的服务器。

- **数据完整性**

    保障传输内容不被篡改。

#### TLS/SSL 的应用

- **HTTPS**

    TLS/SSL 最常见的应用场景，用于加密 HTTP 流量。

- **电子邮件安全**

    如 SMTP over TLS、IMAP over TLS。

- **虚拟专用网络（VPN）**

    TLS 协议用于加密 VPN 流量。

#### TLS/SSL 的局限性

- **复杂性**

    部署和维护需要专业知识。

- **性能影响**

    尤其在握手阶段，加密和解密会增加服务器和客户端的计算负担。

- **信任链依赖**

    依赖证书颁发机构（CA）的可信性。

### 常见的加密方式

#### 对称加密

采用单钥密码系统的加密方法，同一个密钥可以同时用作信息的加密和解密，这种加密方法称为对称加密，也称为单密钥加密，特征：加密和解密所用的密钥是相同的

常见对称加密算法（了解）：DES、3DES、AES、TDEA、Blowfish、RC2 等

特点：算法公开、计算量小、加密速度快、加密效率高

对称加密其实就是通过同一个“密钥”，把明文加密成密文，并且也能把密文解密成明文。

一个简单的对称加密，按位异或

假设明文 $a=1234$，密钥 $key = 8888$

则加密 $a\oplus key$ 得到的密文 $b$ 为 9834.

然后针对密文 9834 再次进行运算 $b\oplus key$，得到的就是原来的明文 1234.

（对于字符串的对称加密也是同理，每一个字符都可以表示成一个数字）

当然，按位异或只是最简单的对称加密。HTTPS 中并不是使用按位异或。

#### 非对称加密

**概念**

需要两个密钥来进行加密和解密，这两个密钥是公开密钥（public key，简称公钥）和私有密钥（private key，简称私钥）。

常见非对称加密算法（了解）：RSA，DSA，ECDSA

**特点**

算法强度复杂、安全性依赖于算法与密钥但是由于其算法复杂，而使得加密解密速度没有对称加密解密的速度快。

非对称加密要用到两个密钥，一个叫做“公钥”，一个叫做”私钥”

公钥和私钥是配对的。最大的缺点就是运算速度非常慢，比对称加密要慢很多.

**用法**

通过公钥对明文加密，变成密文

通过私钥对密文解密，变成明文

也可以反着用

通过私钥对明文加密，变成密文

通过公钥对密文解密，变成明文

### 数据摘要 && 数据指纹

数据摘要为什么叫做数据指纹，因为数据摘要具有唯一性，跟人的指纹一样具有唯一性

数字指纹（数据摘要）其基本原理是利用单向散列函数（Hash 函数）对信息进行运算，生成一串固定长度的数字摘要。数字指纹并不是一种加密机制，但可以用来判断数据有没有被篡改。

**摘要常见算法**：有 MD5、SHA1、SHA256、SHA512 等，算法把无限的映射成有限，因此可能会有碰撞（两个不同的信息，算出的摘要相同，但是概率非常低）

**摘要特征**：和加密算法的区别是，摘要严格意义不是加密，因为没有解密，只不过从摘要很难反推原信息，通常用来进行数据对比

比如数据库明文密码保存——不推荐，我们就可以将密码进行摘要保存

### 数字签名

摘要经过加密，就得到数字签名

## HTTPS 的工作过程探究

既然要保证数据安全，就需要进行“加密”

网络传输中不再直接传输明文了，而是加密之后的“密文”

加密的方式有很多，但是整体可以分成两大类：对称加密和非对称加密

### 方案 1 只使用对称加密

如果通信双方都各自持有同一个密钥 $X$，且没有别人知道，这两方的通信安全当然是可以被保证的（除非密钥被破解）

![图片](http://public.file.lvshuhuai.cn/images\640.webp)

但是我们怎么让客户端双方都知道这个锁是什么呢，如果明文传递的话，不就是又泄露了！

所以只用对称加密，首次的时候，无法同步双方的密钥 $X$。

### 方案 2 只使用非对称加密

鉴于非对称加密的机制，如果服务器先把公钥以明文方式传输给浏览器，之后浏览器向服务器传数据前都先用这个公钥加密好再传，从客户端到服务器信道似乎是安全的（有安全问题），因为只有服务器有相应的私钥能解开公钥加密的数据。

但是服务器到浏览器的这条路怎么保障安全？

如果服务器用它的私钥加密数据传给浏览器，那么浏览器用公钥可以解密它，而这个公钥是一开始通过明文传输给浏览器的，若这个公钥被中间人劫持到了，那他也能用该公钥解密服务器传来的信息了！

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-16.webp)

方案二保证单向的数据安全（但也是临时的），并且运算速度非常慢，所以也不采用！

### 方案 3 双方都使用非对称加密

服务端拥有公钥 $S$ 与对应的私钥 $S'$，客户端拥有公钥 $C$ 与对应的私钥 $C'$

客户和服务端交换公钥

客户端给服务端发信息：先用 $S$ 对数据加密，再发送，只能由服务器解密，因为只有服务器有私钥 $S'$

服务端给客户端发信息：先用 $C$ 对数据加密，在发送，只能由客户端解密，因为只有客户端有私钥 $C'$

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-17.webp)



#### 存在的问题

其实也并不安全！（同方案二）

通信速度会比较慢！

### 方案 4 非对称加密 + 对称加密

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-18.webp)

#### 通信过程

服务端具有非对称公钥 $S$ 和私钥 $S'$

客户端发起 https 请求，获取服务端公钥 $S$

客户端在本地生成对称密钥 $C$，通过公钥 $S$ 加密，发送给服务器

由于中间的网络设备没有私钥，即使截获了数据，也无法还原出内部的原文，也就无法获取到对称密钥（真的吗？）

服务器通过私钥 $S'$ 解密，还原出客户端发送的对称密钥 $C$。并且使用这个对称密钥加密给客户端返回的响应数据。

后续客户端和服务器的通信都只用对称加密即可。由于该密钥只有客户端和服务器两个主机知道，其他主机/设备不知道密钥即使截获数据也没有意义。

由于对称加密的效率比非对称加密高很多，因此只是在开始阶段协商密钥的时候使用非对称加密，后续的传输仍然使用对称加密，所以效率问题解决了！

虽然上面已经比较接近答案了，但是依旧有安全问题

方案 2，方案 3，方案 4 都存在一个问题，如果最开始，中间人就已经开始攻击了呢？

### 中间人攻击——针对上面的场景

Man-in-the-MiddleAttack，简称“MITM 攻击”

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-19.webp)

确实，在方案 2/3/4 中，客户端获取到公钥 $S$ 之后，对客户端形成的对称秘钥 $X$ 用服务端给客户端的公钥 $S$ 进行加密，中间人即使窃取到了数据，此时中间人确实无法解出客户端形成的密钥 $X$，因为只有服务器有私钥 $S'$。

但是中间人的攻击，如果在最开始握手协商的时候就进行中间人攻击了，那就不一定了，假设 hacker 已经成功成为中间人了呢？！

#### 攻击流程

服务器具有非对称加密算法的公钥 $S$，私钥 $S'$

中间人具有非对称加密算法的公钥 $M$，私钥 $M'$

客户端向服务器发起请求，服务器明文传送公钥 $S$ 给客户端

中间人劫持数据报文，提取公钥 $S$ 并保存好，然后将被劫持报文中的公钥 $S$ 替换成为自己的公钥 $M$，并将伪造报文发给客户端

客户端收到报文，提取公钥 $M$（自己当然不知道公钥被更换过了），自己形成对称秘钥 $X$，用公钥 $M$ 加密 $X$，形成报文发送给服务器

中间人劫持后，直接用自己的私钥 $M'$ 进行解密，得到通信秘钥 $X$，再用曾经保存的服务端公钥 $S$ 加密后，将报文推送给服务器

服务器拿到报文，用自己的私钥 $S'$ 解密，得到通信秘钥 $X$

双方开始采用 X 进行对称加密，进行通信。但是一切都在中间人的掌握中，劫持数据，进行窃听甚至修改，都是可以的

上面的攻击方案，同样适用于方案 2，方案 3

问题本质出在哪里了呢？客户端无法确定收到的公钥是否是合法的！那么如何让 client 得知，自己收到的“公钥”是合法的呢？

### 证书的引入

#### CA 认证

服务端在使用 HTTPS 前，需要向 CA 机构申领一份数字证书，数字证书里含有证书申请者信息、公钥信息等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了，证书就如身份证，证明服务端公钥的权威性

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-20.webp)

这个证书可以理解成是一个结构化的字符串，里面包含了以下信息：

- 证书发布机构
- 证书有效期
- 公钥
- 证书所有者
- 签名

### 理解数据签名

数据签名就是将数据摘要或者指纹进行加密。

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-21.webp)

当服务端申请 CA 证书的时候，CA 机构会对该服务端进行审核，并专门为该网站形成

#### 数字签名过程

CA 机构拥有非对称加密的私钥 $A$ 和公钥 $A'$

CA 机构对服务端申请的证书明文数据进行 hash，形成数据摘要

然后对数据摘要用 CA 私钥 $A'$ 加密，得到数字签名 $S$

#### 验证过程

接收到数据时，先将原始数据和签名分开，

然后原始数据通过同样的散列算法再次获得到一个散列值。

将签名通过签名者的公钥进行解密，新散列值和签名进行比较，最终就可以判断数据是否有被更改了！

那么客户端的签名者公钥是从哪里来的呢？

所有的浏览器（客户端），一般都要有内置可信的 CA 机构或者授权的子机构的公钥！

### HTTPS最终方案：非对称加密 + 对称加密 + 证书认证

在客户端和服务器刚一建立连接的时候，服务器给客户端返回一个 证书，证书包含了之前服务端的公钥，也包含了网站的身份信息.

#### 客户端进行认证

client 第一次请求，得到返回结果，不仅仅得到了公钥，实际上 client 得到的是一个“证书”，CA 机构签发的证书。

客户端获取到这个证书之后，会对证书进行校验（防止证书是伪造的）

判定证书的有效期是否过期

判定证书的发布机构是否受信任（操作系统中已内置的受信任的证书发布机构）

验证证书是否被篡改：从系统中拿到该证书发布机构的公钥，对签名解密，得到一个 hash 值（称为数据摘要），设为 hash1。 然后计算整个证书的 hash 值，设为 hash2。对比 hash1 和 hash2 是否相等。如果相等，则说明证书是没有被篡改过的

#### 常见问题

1. 中间人有没有可能篡改该证书？

    由于中间人没有 CA 机构的私钥，所以无法 hash 之后用私钥加密形成签名，那么也就没法办法对篡改后的证书形成匹配的签名，这个世界上只有 CA 机构有私钥，也就意味着，只有 CA 机构才有对数据进行签名的能力！

2. 中间人整个掉包证书？

    因为中间人没有 CA 私钥，所以无法制作假的证书

    所以中间人只能向 CA 申请真证书，然后用自己申请的证书进行掉包

    这个确实能做到证书的整体掉包，但是别忘记，证书明文中包含了域名等服务端认证信息，如果整体掉包，客户端依旧能够识别出来。

永远记住：中间人没有 CA 私钥，所以对任何证书都无法进行合法修改，包括自己的

3. 为什么签名不直接加密，而是要先 hash 形成摘要？

    缩小签名密文的长度，加快数字签名的验证签名的运算速度

#### HTTPS通信的完整流程

![图片](http://public.file.lvshuhuai.cn/images\640-1735098590006-22.webp)

#### HTTPS 工作过程中涉及到的密钥有三组

**第一组（非对称加密）**：用于校验证书是否被篡改。服务器持有私钥（私钥在形成 CSR 文件与申请证书时获得），客户端持有公钥（操作系统包含了可信任的 CA 认证机构有哪些，同时持有对应的公钥）。服务器在客户端请求时，返回携带签名的证书。客户端通过这个公钥进行证书验证，保证证书的合法性，进一步保证证书中携带的服务端公钥权威性。

**第二组（非对称加密）**：用于协商生成对称加密的密钥。客户端用收到的 CA 证书中的公钥（是可被信任的）给随机生成的对称加密的密钥加密，传输给服务器，服务器通过私钥解密获取到对称加密密钥。

**第三组（对称加密）**：客户端和服务器后续传输的数据都通过这个对称密钥加密解密。

其实一切的关键都是围绕这个对称加密的密钥。其他的机制都是辅助这个密钥工作的！

## 证书的获得方式

### 商用的证书

贵

### 个人开发者的免费方式

截止 2024 年 12 月 25 日

#### 阿里云

- 推荐指数：★★☆☆☆
- 免费证书类型：DV 域名型
- 免费证书品牌：DigiCert（原赛门铁克（Symantec））
- 免费通配符证书：不支持
- 易操作性：简单
- 证书有效期： 1年
- 自动更新：不支持
- 自动部署： 不支持
- 优点：有效期长

阿里云仅提供免费的单域名 HTTPS 证书，如果你仅只需要一个单域名的证书，可以使用阿里云的免费证书，毕竟 DigiCert 是大品牌，值得信赖。在证书即将到期前，需要再次手动申请证书，不支持自动化申请和部署。申请链接：https://common-buy.aliyun.com/?commodityCode=cas#/buy

#### 腾讯云

- 推荐指数：★★☆☆☆
- 免费证书类型：DV 域名型
- 免费证书品牌：TrustAsia（即亚洲诚信）
- 免费通配符证书：不支持
- 易操作性：简单
- 证书有效期： 1年
- 自动更新：不支持
- 自动部署： 不支持

腾讯云同阿里云一样，仅提供免费的单域名 HTTPS 证书，如果你仅只需要一个单域名的证书，同样可以使用腾讯云的免费证书，TrustAsia 也是比较大的品牌。在证书即将到期前，需要再次手动申请证书，不支持自动化申请和部署。申请链接：https://buy.cloud.tencent.com/ssl?fromSource=ssl

#### certbot

- 推荐指数：★★★☆☆
- 免费证书类型：DV 域名型
- 免费证书品牌：Let's Encrypt
- 免费通配符证书：支持
- 易操作性：困难
- 证书有效期： 90天
- 自动更新：支持
- 自动部署： 支持

这里先说下 Let's Encrypt 证书品牌：Let's Encrypt 是免费、开放和自动化的世界知名证书颁发机构，由非盈利组织互联网安全研究小组（ISRG）运营。Let's Encrypt 已为全世界 1.8 亿个网站提供 HTTPS 证书，可放心使用。

再说下这个[certbot](https://certbot.eff.org/)：certbot 是一个脚本类型的 Let's Encrypt 证书申请客户端，需要一定的命令行使用经验方可操作，如需自动更新，还需要添加插件，使用起来比较困难。如有自动更新和自动部署需求，建议使用下面介绍的 acme.sh 和 ohttps.com。

#### acme.sh

- 推荐指数：★★★★★
- 免费证书类型：DV 域名型
- 免费证书品牌：Let's Encrypt
- 免费通配符证书：支持
- 易操作性：一般
- 证书有效期： 90天
- 自动更新：支持
- 自动部署： 支持

[acme.sh](https://github.com/acmesh-official/acme.sh) 是一个知名的用于申请 Let's Encrypt 证书的开源项目，项目地址：[https://github.com/acmesh-official/acme.sh](https://github.com/acmesh-official/acme.sh?spm=a2c6h.12873639.article-detail.8.3c6b4df5XUjgAf&file=acme.sh)，也是属于脚本类型，有比较详细的文档，支持自动化更新和自动化部署。唯一缺点，如果有更新后自动部署至多个节点的需求的话，acme.sh 无法满足。如果你有一定的命令行使用经验，acme.sh 使用起来还是非常方便，强烈推荐！关于更新后自动部署至多个节点的需求，建议使用下面介绍的 ohttps.com。

#### freessl.cn

- 推荐指数：★★★☆☆
- 免费证书类型：DV 域名型
- 免费证书品牌：Let's Encrypt、TrustAsia
- 免费通配符证书：支持 Let's Encrypt 的通配符类型证书
- 易操作性：简单
- 证书有效期： Let's Encrypt 通配符证书有效期 90 天、TrustAsia 双域名证书有效期1年
- 自动更新：不支持
- 自动部署： 不支持

[freessl.cn](https://freessl.cn/) 提供免费的 Let's Encrypt 和 TrustAsia 证书申请，Let's Encrypt 支持通配符类型，TrustAsia 仅支持双域名类型证书。申请界面比较友好，根据提示在域名解析记录中添加指定的 TXT 类型域名解析即可，对于不会使用命令行的小白用户来说使用起来比较简单。申请链接：https://freessl.cn/

#### ohttps.com

- 推荐指数：★★★★★
- 免费证书类型：DV 域名型
- 免费证书品牌：Let's Encrypt
- 免费通配符证书：支持
- 易操作性：简单
- 证书有效期： 90天
- 自动更新：支持
- 自动部署： 支持

[ohttps.com](https://ohttps.com/) 提供了类似于 acme.sh 的功能，不过提供了友好的管理界面，可申请 Let's Encrypt 免费通配符类型证书，还提供了证书吊销、到期前提醒、自动更新、自动部署功能。另外比 acme.sh 增加了一些非常实用的功能，主要包括可自动部署至阿里云、腾讯云、七牛云的负载均衡、内容分发 CDN、SSL 证书列表等，并可自动部署至多个 nginx 容器中。申请链接：[https://ohttps.com](https://ohttps.com/)

## 一个例子

这里使用本人开发的 Where Money 钱去哪儿了项目作为实验。

### 项目背景

- 前后端分离架构
- 前端端口使用 13140，后端使用 5050
- 之前用 NGINX 做了域名的反向代理，访问 [http://where-money.lvshuhuai.cn/](http://where-money.lvshuhuai.cn/) 代理到前端页面，后端没有代理，直接域名+端口号的形式访问，后端 API 地址为 [http://lvshuhuai.cn:5050/](http://lvshuhuai.cn:5050/)
- 前端直接使用 `npm run serve` 运行，没有 build 过静态文件
- 项目中涉及到图片的存储和使用，直接保存 Blob 到 MySQL 中，没有使用 OSS 或其他 Http 文件存储服务

### 申请证书

#### 泛域名证书

<img src="http://public.file.lvshuhuai.cn/images\image-20241225132444654.png" alt="image-20241225132444654" style="zoom:50%;" />

#### 添加访问秘钥

<img src="http://public.file.lvshuhuai.cn/images\image-20241225132654230.png" alt="image-20241225132654230" style="zoom:50%;" />

#### 验证域名

<img src="http://public.file.lvshuhuai.cn/images\image-20241225132541895.png" alt="image-20241225132541895" style="zoom:50%;" />

#### 等待申请

#### 下载证书文件

<img src="http://public.file.lvshuhuai.cn/images\image-20241225132757869.png" alt="image-20241225132757869" style="zoom:50%;" />

#### 配置 NGINX

```nginx
# 将之前的解析改变
# server {
#     listen       [::]:80;
#     server_name owiviosa.lvshuhuai.cn;
#     location / {
#         proxy_pass http://localhost:19232;
#     }
# }
# 让 http 自动重定向到 https
server {
    listen       [::]:80;
    server_name where-money.lvshuhuai.cn;
    return 301 https://$host$request_uri;
}
# 前端
server {
    listen 443 ssl;
    listen [::]:443 ssl;
    server_name where-money.lvshuhuai.cn;
    ssl_certificate C:\\CA\\fullchain.pem;
    ssl_certificate_key C:\\CA\\certkey.pem;
    location / {
        proxy_pass http://localhost:13140/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
# 后端
server {
    listen 5051 ssl;
    listen [::]:5051 ssl;
    server_name lvshuhuai.cn;
    ssl_certificate C:\\CA\\fullchain.pem;
    ssl_certificate_key C:\\CA\\certkey.pem;
    location / {
        proxy_pass http://localhost:5050/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

**这里需要代理后端的原因**是：

可以在 SpringBoot 里配置 SSL 证书的信息，但是这需要改代码和重新打包，很麻烦，这里直接使用 NGINX 代理并重定向。

#### 修改前端中的 API 地址

```python
# VITE_APP_INTERFACE_URL = 'http://lvshuhuai.cn:5050/api/'
VITE_APP_INTERFACE_URL = 'https://lvshuhuai.cn:5051/api/'
```

#### 重启 NGINX、重启前端

#### 结果

<img src="http://public.file.lvshuhuai.cn/images\12e6876005fc2b13de26dbdcef6d4ad.png" alt="12e6876005fc2b13de26dbdcef6d4ad" style="zoom:50%;" />

#### 每 90 天需要更新一下 SSL 证书

SSL 证书的有效期只有 90 天

需设置自动化配置

~~这里使用 API 方式~~

较为麻烦之后再说

<img src="http://public.file.lvshuhuai.cn/images\image-20241225135946679.png" alt="image-20241225135946679" style="zoom:50%;" />

<img src="http://public.file.lvshuhuai.cn/images\image-20241225140042967.png" alt="image-20241225140042967" style="zoom:50%;" />

