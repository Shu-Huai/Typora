# 05 登录模块开发

# 登录页设计：支持响应式布局

本章节正式开始开发第一个功能：*登录模块*。涉及到前端页面、以及后台登录接口的开发工作，废话不多说，本小节中，小哈就先带着大家搞定一个响应式布局（支持 PC 、移动端）的登录页面。

## 先上最终效果图

![img](http://public.file.lvshuhuai.cn/images\169260760836420.jpeg)

## 开始动手

### 基本布局

首先，我们通过 Tailwind 的 `grid` 网格布局，实现一个登录页面的基本骨架，分为左边栏和右边栏，代码如下：

```php-template
<template>
	<!-- 使用 grid 网格布局，并指定列数为 2，高度占满全屏 -->
    <div class="grid grid-cols-2 h-screen">
	    <!-- 默认先适配移动端，占两列，order 用于指定排列顺序，md 用于适配非移动端（PC 端）；背景色为黑色 -->
        <div class="col-span-2 order-2 p-10 md:col-span-1 md:order-1 bg-black">
                左边栏
        </div>
        <div class="col-span-2 order-1 md:col-span-1 md:order-2 bg-white">
                右边栏
        </div>
    </div>
</template>
```

- 上述代码中，先指定了父级 `div` 为 `grid` 网格布局，并指定列数为 2，高度占满全屏；
- 然后对左右边栏，设置了占 2 列，当占满父级列数时，会自动换行，上下布局，这么做是为了适配移动端。然后通过 `md` 来单独配置 PC 端的展示规则，各占 1 列，呈左右布局。`order` 用来指定排序规则；
- `bg-xxx` 用于指定背景色；

上面代码，展示效果如下：

![img](http://public.file.lvshuhuai.cn/images\169260823400127.jpeg)

达到了我们的基本要求。左右布局，各占一半。

### 内容居中

我们还需要内容居中显示，修改代码如下：

```php-template
<template>
    <div class="grid grid-cols-2 h-screen">
        <div class="col-span-2 order-2 md:col-span-1 md:order-1 bg-black">
        	<!-- 指定为 flex 布局，并设置为屏幕垂直水平居中，高度为 100% -->
            <div class="flex justify-center items-center h-full">
                左边栏
            </div>
        </div>
        <div class="col-span-2 order-1 md:col-span-1 md:order-2 bg-white">
            <div class="flex justify-center items-center h-full">
                右边栏
            </div>
        </div>
    </div>
</template>
```

上述代码中，我们将 `左边栏`、`右边栏` 再包了一层 `div`, 同时指定为 `flex` 布局，并通过 `justify-center items-center` 设置为屏幕垂直水平居中，`h-full` 指定高度为 100%。

### 右边栏登录表单

#### Element Plus 图标库安装

在写登录表单之前，还需要先安装一下 Element Plus 官方提供的图标库，因为使用 Element Plus 输入框时，如果需要添加前缀图标，需要用到：

![img](http://public.file.lvshuhuai.cn/images\169260874683883.jpeg)

在命令行中执行如下安装命令：

```bash
npm install @element-plus/icons-vue
```

#### 注册图标

编辑 `main.js` 文件，注册图标：

```javascript
// 导入 Element Plus 图标
import * as ElementPlusIconsVue from '@element-plus/icons-vue'

// 省略 ...

// 引入图标
for (const [key, component] of Object.entries(ElementPlusIconsVue)) {
    app.component(key, component)
}

// 省略 ...
```

注册完成后，我们就可以正常使用图标了。

#### 设计登录表单

登录表单代码如下：

```php-template
<template>
    <div class="grid grid-cols-2 h-screen">
        <div class="col-span-2 order-2 md:col-span-1 md:order-1 bg-black">
            <div class="flex justify-center items-center h-full">
                左边栏
            </div>
        </div>
        <div class="col-span-2 order-1 md:col-span-1 md:order-2 bg-white">
        	<!-- flex-col 用于指定子元素垂直排列 -->
            <div class="flex justify-center items-center h-full flex-col">
                <h1>欢迎回来</h1>
                <div>
                    账号密码登录
                </div>
                <!-- 引入 Element Plus 表单组件，移动端设置宽度为 5/6，PC 端设置为 2/5 -->
                <el-form class="w-5/6 md:w-2/5">
                    <el-form-item>
                    	<!-- 输入框组件 -->
                        <el-input size="large" placeholder="请输入用户名" :prefix-icon="User" clearable/>
                    </el-form-item>
                    <el-form-item>
	                    <!-- 密码框组件 -->
                        <el-input size="large" type="password" placeholder="请输入用户名" :prefix-icon="Lock" clearable/>
                    </el-form-item>
                    <el-form-item>
                    	<!-- 登录按钮，宽度设置为 100% -->
                        <el-button class="w-full" size="large" type="primary">登录</el-button>
                    </el-form-item>
                </el-form>
                
            </div>
        </div>
    </div>
</template>

<script setup>
// 引入 Element Plus 中的用户、锁图标
import { User, Lock } from '@element-plus/icons-vue'
</script>
```

上述代码中，我们通过 `flex-col` 将子元素指定为垂直排列，并引入了 Element Plus 表单组件 , 并添加了两个输入框和一个登录按钮，相关组件可访问 Element Plus 官网来查看具体用法示例。此时效果图如下：

![img](http://public.file.lvshuhuai.cn/images\169260269008066.jpeg)

登录表单的样式就搞定了，这个时候，你会发现*输入框还无法输入内容，暂时先不用管*，因为还没给它添加 `v-model` 指令双向绑定，本小节先把静态页面整好，后面再完善这块。

#### 解决样式冲突问题

当访问登录页时，若发现 Element Plus 输入框组件的样式混含了 `flowbite` 的样式，如下图所示：

![img](http://public.file.lvshuhuai.cn/images\169260423573829.jpeg)

只需在 `main.css` 文件中添加如下代码，重写一下相关样式即可恢复正常·：

```css
[type='text']:focus, [type='email']:focus, [type='url']:focus, [type='password']:focus, [type='number']:focus, [type='date']:focus, [type='datetime-local']:focus, [type='month']:focus, [type='search']:focus, [type='tel']:focus, [type='time']:focus, [type='week']:focus, [multiple]:focus, textarea:focus, select:focus {
  box-shadow: 0 0 0 1px transparent inset!important;
}
```

#### 表单上方文字美化

再来美化一下登录表单上面的文字：

```php-template
// 省略 ...
<!-- 大标题，设置字体粗细、大小、下边距 -->
<h1 class="font-bold text-4xl mb-5">欢迎回来</h1>
<!-- 设置 flex 布局，内容垂直水平居中，文字颜色，以及子内容水平方向 x 轴间距 -->
<div class="flex items-center justify-center mb-7 text-gray-400 space-x-2">
    <!-- 左边横线，高度为 1px, 宽度为 16，背景色设置 -->
    <span class="h-[1px] w-16 bg-gray-200"></span>
    <span>账号密码登录</span>
    <!-- 右边横线 -->
    <span class="h-[1px] w-16 bg-gray-200"></span>
</div>
// 省略 ...
```

最终效果图如下：

![img](http://public.file.lvshuhuai.cn/images\169260509973716.jpeg)

OK, 右边栏的样式布局就搞定了。

### 左边栏

接下来，再来添加左边栏的内容，代码如下：

```php-template
// 省略...
<!-- 默认占两列，order 用于指定排列顺序，md 用于适配非移动端（PC 端） -->
<div class="col-span-2 order-2 p-10 md:col-span-1 md:order-1 bg-slate-900">
    <!-- 指定为 flex 布局，并设置为屏幕垂直水平居中，高度为 100% -->
    <div class="flex justify-center items-center h-full flex-col">
        <h2 class="font-bold text-4xl mb-7 text-white">Weblog 博客登录</h2>
        <p class="text-white">一款由 Spring Boot + Mybaits Plus + Vue 3.2 + Vite 4 开发的前后端分离博客。</p>
        <!-- 指定图片宽度为父级元素的 1/2 -->
        <img src="@/assets/developer.png" class="w-1/2">
    </div>
</div>
```

上述代码中，我们将左边栏的总体背景色设置为了 `bg-slate-900`, 内容上依旧是 `flex-col` 垂直排列，并添加了一些描述性的文字，以及一张背景色透明的图片，效果如下：

![img](http://public.file.lvshuhuai.cn/images\169260760836420.jpeg)

#### 图片哪里有现成的？

小哈给大家推荐一个阿里的网站： https://www.iconfont.cn/ ， 这个网站提供了丰富、美观的图标、插画等资源，大家可自行搜索下载，并使用到自己的项目中：

![img](https://img.quanxiaoha.com/quanxiaoha/169260938075792)

接下来，我来演示一下，小哈是怎么搜索并下载一个还算好看的插画，并应用到 `weblog` 项目中。在搜索栏中输入对应关键字，比如 *程序员*，勾选类别为*插画*：

![img](https://img.quanxiaoha.com/quanxiaoha/169260951497818)

选择一张自己喜欢的插画，点击下载：

![img](https://img.quanxiaoha.com/quanxiaoha/169260960778093)

等待加载完成后，点击背景，默认背景色为白色，这和我们想要设置的背景色有冲突，最好是*手动将背景色设置为透明*，然后点击下载 PNG 图片：

![img](https://img.quanxiaoha.com/quanxiaoha/169260968616045)

下载成功后，将图片复制到项目中的 `assets` 文件夹下，这个文件夹主要用于放置相关资源文件，同时，将图片命名为 `developer.png` ，方便后续管理：

![img](https://img.quanxiaoha.com/quanxiaoha/169260979813940)

有了图片，后续通过 `<img>` 图片标签直接引用即可，如下所示：

```cpp
<img src="@/assets/developer.png" class="w-1/2">
```

## 本小节对应源码

https://t.zsxq.com/11JvumrI6

## 结语

到这里，本小节的目标：设计一个响应式的登录页就完成了，目前还只是静态页面，后续还需要和服务端交互，来完成一个完整的登录功能。

# 登录页加点盐：通过 Animate.css 添加入场动画

本小节中，小哈将带着大家通过 `Animate.css` 给登录页添加入场动画，让页面过渡更加友好，提升逼格。

## 最终完成的效果图

![img](http://public.file.lvshuhuai.cn/images\169266850100221.gif)

## Animate.css 是什么？

`Animate.css` 是一个跨浏览器的 CSS 动画库，提供了许多预设的、流畅的动画效果。用户只需添加几个 CSS 类名，就可以轻松实现复杂的动画效果，无需编写任何 JavaScript 代码。

## 为什么使用 Animate.css？

- **简单易用**：通过添加或删除类名，你可以触发动画，这使得实现动画效果变得非常直观。
- **高性能和跨浏览器**：`Animate.css` 专为性能进行了优化，并在多数现代浏览器中表现良好。
- **丰富的动画选择**：无需从零开始设计动画，库中提供了大量预制动画，如“fadeIn”、“bounce”、“zoomIn”等。
- **与 Vue 配合完美**：Vue 提供了 `transition` 组件，可以与 `Animate.css` 轻松结合，为你的 Vue 应用添加精美动画。

## 开始动手

### 安装

打开命令行，执行如下安装命令：

```css
npm install animate.css --save
```

### 引入

在 `main.js` 文件中引入它：

```go
import 'animate.css';
```

![img](http://public.file.lvshuhuai.cn/images\169266742378117.jpeg)

引入后，就可以添加相关动画效果了。

### 选择自己喜欢的动画效果

可访问 `Animate.css` 官网：https://animate.style/ ，右侧栏是支持的动画，点击可查看效果，喜欢哪个就复制哪个，并应用到自己的项目中：

![img](http://public.file.lvshuhuai.cn/images\169266767706386.jpeg)

### 添加弹跳动画

编辑 `/admin/login.vue` ，给右边栏的父级 `div` 添加 `bounceInRight` 动画，样式类名如下：

```markdown
animate__animated animate__bounceInRight animate__fast
```

- `animate__animated` : Animate.css 中的一个核心类名，它被用于触发动画效果。这个类名为元素定义了动画的基础属性，使其能够与其他具体的动画效果类名（如 `animate__fadeIn`、`animate__bounce` 等）结合使用，从而产生动画效果;
- `animate__bounceInRight` : 指定为从右弹入；
- `animate__fast` : 指定动画速度为快；

![img](http://public.file.lvshuhuai.cn/images\169266799062954.jpeg)

再给左边栏的父级 `div` 添加 `bounceInLeft` 动画，样式类名如下：

```markdown
animate__animated animate__bounceInLeft animate__fast
```

![img](http://public.file.lvshuhuai.cn/images\169266822917871.jpeg)

- `animate__bounceInLeft` : 指定从左弹入动画；

添加完成相关动画，再次访问页面，即可看到文章头所示的效果啦~

## 本小节对应源码

https://t.zsxq.com/11WIfCYJz

## 结语

`Animate.css` 提供了一种简单但强大的方式来给 Web 应用增加吸引人的动画效果。与 Vue 3 的整合使得在应用中添加动画变得更为直接和简洁。为你的用户带去更加动态和生动的体验，无疑可以提高用户的满意度和参与度。

# 整合 Mybatis Plus

到目前为止，已经将登录的静态页面完成了。接下来，我们将转入后端开发，将登录相关的接口搞定。因为登录功能涉及到从数据库中查询用户名、密码，所以，这小节中，我们需要先将持久层框架 Mybatis Plus 整合到项目中来。

![img](http://public.file.lvshuhuai.cn/images\164870378749787.png)

## 什么是 MyBatis Plus？

**MyBatis Plus （简称 MP） 是一款持久层框架**，说白话就是一款操作数据库的框架。它是**一个 MyBatis 的增强工具**，就像 iPhone手机一般都有个 plus 版本一样，它在 MyBatis 的基础上只做增强不做改变，为简化开发、提高效率而生。

MyBatis Plus 的愿景是成为 MyBatis 最好的搭档，就像魂斗罗中的 1P、2P，基友搭配，效率翻倍。

## MyBatis Plus 的优势

- **快速开发**：MyBatis Plus 提供了一系列的便捷功能，如自动生成 SQL 语句、通用 Mapper 等，使数据库操作更加高效，能够节省开发时间。
- **更少的配置**： Spring Boot 已经为我们提供了很多默认的配置，整合 MyBatis Plus 时只需少量的配置，减少了繁琐的配置步骤。
- **内置分页插件**：MyBatis Plus 内置了分页插件，无需额外的代码，就可以轻松实现分页查询。
- **更好的支持**： MyBatis Plus 在社区中有较广泛的使用，拥有活跃的维护者和开发者，您可以轻松找到解决方案和文档。

## 数据库安装

首先，你需要先确保你的电脑已安装好 MySQL 。不知道如何安装的童鞋，可自行百度一下，比较简单。

> TIP : 也可以使用 Docker 安装 MySQL 环境，可参考小哈之前的一篇文章：[《Docker 安装 MySQL 环境》](https://www.quanxiaoha.com/docker/docker-install-mysql.html)

## 新建测试库与表

数据库安装好后，我们可以下载一个数据库操作工具，可以更方便的操作数据库，小哈这里使用的是 Navicat 16 版本。

> Navicat 16 版本的下载和破解方法，可参考我这篇文章：[《Navicat 16 破解图文教程》](https://www.quanxiaoha.com/article/navicat16-pojie.html) 。

![img](http://public.file.lvshuhuai.cn/images\167030384464994.jpeg)

### 连接数据库

通过 Navicat 来连接刚刚新建好的数据库，操作步骤为点击左上角菜单 *文件 -> 新建连接 -> MySQL* :

![img](http://public.file.lvshuhuai.cn/images\169269220109288.jpeg)

填写数据库连接相关信息，如用户名、密码等，填写好后，点击左下角的*测试连接*，看看是否能够正确连接上，若是，则点击*确定*按钮：

![img](http://public.file.lvshuhuai.cn/images\169269249913161.jpeg)

### 建库

在数据库上右键，新建一个名为 `weblog` 的数据库：

![img](http://public.file.lvshuhuai.cn/images\169269266051836.jpeg)

注意，字符集设定为 `utfmb4`, 让数据库支持 `emojis` 表情符号：

![img](http://public.file.lvshuhuai.cn/images\169269275387237.jpeg)

### 建表

在 `weblog` 库右键，新建查询：

![img](http://public.file.lvshuhuai.cn/images\169269298008543.jpeg)

执行如下建表语句：

```sql
CREATE TABLE `user`
(
    `id`          bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT 'id',
    `username`    varchar(60)         NOT NULL COMMENT '用户名',
    `password`    varchar(60)         NOT NULL COMMENT '密码',
    `create_time` datetime            NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime            NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '最后一次更新时间',
    `is_deleted`  tinyint(2)          NOT NULL DEFAULT '0' COMMENT '逻辑删除：0：未删除 1：已删除',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `uk_username` (`username`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4 COMMENT ='用户表';
```

## 开始整合

数据库、表都准备好后，我们开始在项目中整合持久层框架 Mybatis Plus。

### 添加依赖

在父项目 `weblog-springboot` 的 `pom.xml` 文件中，声明 MP 的依赖版本号：

```xml
	<!-- 版本号统一管理 -->
    <properties>
        // 省略...
        <mybatis-plus.version>3.5.2</mybatis-plus.version>
    </properties>
    
        <!-- 统一依赖管理 -->
    <dependencyManagement>
        <dependencies>
            // 省略...

            <!-- Mybatis Plus -->
            <dependency>
                <groupId>com.baomidou</groupId>
                <artifactId>mybatis-plus-boot-starter</artifactId>
                <version>${mybatis-plus.version}</version>
            </dependency>

        </dependencies>
    </dependencyManagement>
```

然后，在 `weblog-module-common` 模块的 `pom.xml` 文件中，引入 MP 和 MySQL 依赖：

```xml
		<!-- Mybatis Plus -->
		<dependency>
			<groupId>com.baomidou</groupId>
			<artifactId>mybatis-plus-boot-starter</artifactId>
		</dependency>
		
		<!-- mysql 依赖 -->
		<dependency>
			<groupId>mysql</groupId>
			<artifactId>mysql-connector-java</artifactId>
		</dependency>
```

### 配置文件

编辑 `applicaiton-dev.yml` 文件，添加数据库链接相关的配置，包含连接池的配置：

```yaml
spring:
    datasource:
        driver-class-name: com.mysql.cj.jdbc.Driver
        url: jdbc:mysql://******/weblog_dev?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&useSSL=false&zeroDateTimeBehavior=convertToNull
        username: lvzhi
        password: ******
        hikari:
            minimum-idle: 5
            maximum-pool-size: 20
            auto-commit: true
            idle-timeout: 30000
            pool-name: Weblog-HikariCP
            max-lifetime: 1800000
            connection-timeout: 30000
            connection-test-query: SELECT 1
```

解释一下各个配置的含义和作用：

- `spring.datasource.driver-class-name`: 指定数据库驱动类的完整类名，这里使用的是 MySQL 数据库的驱动类。
- `spring.datasource.url`: 数据库连接的URL，指向本地的MySQL数据库，端口是3306，数据库名是`weblog`，同时配置了一系列参数，如使用Unicode编码、字符编码为UTF-8、自动重连、不使用SSL、对零时间进行转换等。
- `spring.datasource.username`: 数据库用户名，这里使用的是`root`。
- `spring.datasource.password`: 数据库密码，这里使用的是`123456`。

数据库链接池这块，我们使用的 Spring Boot 默认的 HikariCP，它是一个高性能的连接池实现 , 同时，它号称是速度最快的连接池：

- `spring.datasource.hikari.minimum-idle`: Hikari连接池中最小空闲连接数。
- `spring.datasource.hikari.maximum-pool-size`: Hikari连接池中允许的最大连接数。
- `spring.datasource.hikari.auto-commit`: 连接是否自动提交事务。
- `spring.datasource.hikari.idle-timeout`: 连接在连接池中闲置的最长时间，超过这个时间会被释放。
- `spring.datasource.hikari.pool-name`: 连接池的名字。
- `spring.datasource.hikari.max-lifetime`: 连接在连接池中的最大存活时间，超过这个时间会被强制关闭。
- `spring.datasource.hikari.connection-timeout`: 获取连接的超时时间。
- `spring.datasource.hikari.connection-test-query`: 用于测试连接是否可用的SQL查询，这里使用的是`SELECT 1`，表示执行这个查询来测试连接。

然后，在 `weblog-module-common` 模块中的 `config` 包下，新建一个 `MybatisPlusConfig` 配置文件，代码如下：

```java
package shuhuai.weblogbackend.common.config;

import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Configuration;

/**
 * &#064;description:  Mybatis Plus 配置文件
 **/
@Configuration
@MapperScan("shuhuai.weblogbackend.common.domain.mapper")
public class MybatisPlusConfig {
}
```

- `@Configuration` : 此注解声明该类为配置类；

- `@MapperScan` : 扫描 MP 的 `mapper` 接口存放位置。PS: 数据库相关的代码，我们统一放置在 `/domain` 这个包中，格式如下：

  ![img](http://public.file.lvshuhuai.cn/images\169269468935130.jpeg)

  - `dos` : 根据阿里的开发规范，统一将数据库对应的实体类命名为 `xxxDO` 这种形式，统一存放此包下。
  - `mapper` : 统一放置 `mapper` 接口文件；

## 实体类

在 `/dos` 包中，新建一个 `UserDO` 类，字段和数据库中的字段通过转驼峰的形式对应一一对应起来，MP 框架会默认通过这种规则将字段光联在一起，内容如下：

```java
package shuhuai.weblogbackend.common.domain.dos;

import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import com.baomidou.mybatisplus.annotation.TableName;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.util.Date;

/**
 **/
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
@TableName("user")
public class User {
    @TableId(type = IdType.AUTO)
    private Long id;
    private String username;
    private String password;
    private Date createTime;
    private Date updateTime;
    private Boolean isDeleted;
}
```

## 新建 Mapper 接口

在 `mapper`包中，创建一个 `UserMapper` 接口，代码如下：

```java
package shuhuai.weblogbackend.common.domain.mapper;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import shuhuai.weblogbackend.common.domain.dos.User;

/**
 **/
public interface UserMapper extends BaseMapper<User> {
}
```

至此，用于操作数据的前置代码都搞定了。

## 新增一条用户记录

接下来，我们通过单元测试，往数据库中添加一个测试记录，看看能否新增成功。在 `weblog-web` 模块中的单元测试类中，新增一个测试方法，代码如下：

```java
    @Autowired
    private UserMapper userMapper;

    @Test
    void insertTest() {
        // 构建数据库实体类
        User userDO = User.builder()
                .username("殊怀丶")
                .password("******")
                .createTime(new Date())
                .updateTime(new Date())
                .isDeleted(false)
                .build();
        userMapper.insert(userDO);
    }
```

运行该测试方法，看看表中是否被成功插入一条数据：

![img](http://public.file.lvshuhuai.cn/images\169269577099846.jpeg)

可以看到，数据插入成功了。

## 对应章节源码

https://t.zsxq.com/11UpqftJn

## 结语

至此，本小节整合 Mabatis Plus 持久层框架就成功了，有了持久层框架，能够帮助开发人员更方便地进行数据库操作。同时，MyBatis Plus 的强大功能和 Spring Boot 的自动化配置使得整合变得非常简单，节省了开发人员的时间和精力。

# p6spy 组件打印完整的 SQL 语句、执行耗时

![img](http://public.file.lvshuhuai.cn/images\169275319641016.jpeg)

## 一、前言

前面小节中，我们已经在 `weblog` 项目中整合了 Mybatis Plus 。本小节中，我们来配置一下 Mybatis Plus 打印 SQL 功能（包括执行耗时），一方面可以了解到每个操作都具体执行的什么 SQL 语句， 另一方面通过打印执行耗时，也可以提前发现一些慢 SQL，提前做好优化， 省得 DBA 公开处刑。**注意，生产环境不推荐打印执行 SQL，会有数据泄漏风险，仅推荐本地开发使用。**

> TIP : 此种方式为官方推荐，通过 `p6spy` 组件来实现完整的 SQL 打印。请使用 Mybatis Plus 3.1.0 以上版本。

## 二、添加依赖

在父项目 `weblog-springboot` 的 `pom.xml` 文件中，声明 `p6spy` 依赖的版本号：

```xml
    <properties>
        // 省略...
        <p6spy.version>3.9.1</p6spy.version>
    </properties>
    
    <dependencyManagement>
        <dependencies>
			// 省略...
            <dependency>
                <groupId>p6spy</groupId>
                <artifactId>p6spy</artifactId>
                <version>${p6spy.version}</version>
            </dependency>

        </dependencies>
    </dependencyManagement>
```

然后在 `weblog-module-common` 模块中的 `pom.xml` 文件中，引入该依赖：

```xml
		<dependency>
			<groupId>p6spy</groupId>
			<artifactId>p6spy</artifactId>
		</dependency>
```

## 三、添加配置

### 3.1 第一步：修改 `application-dev.yml` 配置文件

`application-dev.yml` 配置文件：

```ruby
spring:
  datasource:
    driver-class-name: com.p6spy.engine.spy.P6SpyDriver
    url: jdbc:p6spy:mysql://127.0.0.1:3306/weblog?useUnicode=true&characterEncoding=UTF-8&autoReconnect=true&useSSL=false&zeroDateTimeBehavior=convertToNull
    ...
```

> **注意：**
>
> - `driver-class-name` : 修改为 `p6spy` 提供的驱动类;
> - `url` ： 修改为前缀为 `jdbc:p6spy` 跟着冒号，后面对应数据库连接地址；

### 3.2 第二步：添加 `p6spy` 配置文件

然后在 `weblog-web` 模块中的 `resources` 目录下添加 `spy.properties` 配置文件：

![img](http://public.file.lvshuhuai.cn/images\169275255938724.jpeg)

配置文件内容如下：

```ini
#3.2.1以上使用
modulelist=com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory
#3.2.1以下使用或者不配置
#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory
# 自定义日志打印
logMessageFormat=com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger
#日志输出到控制台
appender=com.baomidou.mybatisplus.extension.p6spy.StdoutLogger
# 使用日志系统记录 sql
#appender=com.p6spy.engine.spy.appender.Slf4JLogger
# 设置 p6spy driver 代理
deregisterdrivers=true
# 取消JDBC URL前缀
useprefix=true
# 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.
excludecategories=info,debug,result,commit,resultset
# 日期格式
dateformat=yyyy-MM-dd HH:mm:ss
# 实际驱动可多个
#driverlist=org.h2.Driver
# 是否开启慢SQL记录
outagedetection=true
# 慢SQL记录标准 2 秒
outagedetectioninterval=2
```

## 四、看看最终效果

配置添加完成后，再次执行上小节中的单元测试方法 `insertTest()` ，观察控制台输出，效果图如下：

![img](http://public.file.lvshuhuai.cn/images\169275271639639.jpeg)可以看到完整的打印了执行语句，以及执行耗时为 18 ms：

## 五、生产环境不要启用 p6spy

`p6spy` 组件**请勿在生产环境使用，因为有性能损耗，推荐仅本地 `dev` 环境开发开启使用。** 最终做法是，在 `applcation-prod.yml` 文件不启用 `p6spy` 组件，我们将 `application-dev.yml` 的数据库配置复制一份到 `application-prod.yml` 文件中，注意，要将驱动、前缀恢复正常，内容如下：

![img](http://public.file.lvshuhuai.cn/images\169275292105440.jpeg)

## 本小节对应源码

https://t.zsxq.com/11akdecet

## 六、结语

本文给大家介绍了在项目用使用 Mybatis Plus 持久层框架时，如何通过 `p6spy` 组件完整的打印 SQL 语句，以及执行耗时，此功能对于本地开发定位问题、杜绝慢查询都非常有帮助。

# 整合 Spring Security

![img](http://public.file.lvshuhuai.cn/images\169278133655893.jpeg)

在现代的 Web 应用程序中，安全性是系统至关重要的一环。Spring Security 是一个功能强大的安全框架，能够帮助您在应用程序中实现认证（Authentication）和授权（Authorization）功能。本小节中，小哈将带着大家在 `weblog` 项目中初步整合 Spring Security 框架。

## 什么是 Spring Security？

Spring Security 是一个广泛应用于 Java 应用程序的安全框架，旨在保护应用程序免受潜在的安全威胁和攻击。作为 Spring 框架的一部分，Spring Security 提供了强大的功能，帮助开发人员实现身份认证、授权、会话管理以及其他与安全相关的任务。

## 为什么要使用 Spring Security？

- **应用程序保护：** 在当今互联网时代，应用程序安全性至关重要。Spring Security 提供了一系列的安全特性，帮助您保护应用程序免受恶意攻击，确保数据和功能不会被未经授权的用户访问。
- **一站式解决方案：** Spring Security 提供了一个集中的框架来处理各种安全性问题。从用户认证、授权到会话管理，Spring Security 提供了一个一站式的解决方案，使开发人员能够更容易地处理安全问题。
- **多样的认证和授权方式：** Spring Security 允许您以多种方式进行用户认证，包括基本认证、表单认证、OAuth 等。此外，您还可以定义精细的授权规则，确保只有经过授权的用户才能访问特定资源。
- **与 Spring 集成：** Spring Security 可与其他 Spring 项目无缝集成，如 Spring Boot、Spring MVC 等。这使得您可以轻松地将安全性集成到现有的 Spring 应用程序中。
- **高度可定制：** Spring Security 允许您根据应用程序的特定需求进行定制。您可以创建自定义的认证提供者、访问决策器、过滤器等，以适应不同的安全性要求。
- **丰富的社区和文档：** Spring Security 拥有活跃的社区和丰富的文档。您可以在社区中找到许多教程、示例代码和解决方案，以帮助您解决各种安全性问题。
- **符合标准：** Spring Security 符合各种安全性标准和最佳实践，确保您的应用程序满足行业和法规的要求。

无论是保护敏感数据、防范潜在的攻击还是确保只有授权用户能够访问特定功能，Spring Security 都是一个可靠的解决方案。通过提供一系列功能强大的工具，Spring Security 帮助您构建安全可靠的应用程序，确保用户数据和应用程序功能得到充分的保护。

## 新建 weblog-module-jwt 子模块

在整合 Spring Security 框架之前，我们需要新建一个 `weblog-module-jwt` 子模块，它主要用于放置 `jwt` 相关的功能代码。

在父项目 `weblog-springboot` 上右键，新建 `weblog-module-jwt` 子模块，忘记如何创建子模块的小伙伴，可翻阅前面小节[《搭建 Spring Boot 多模块工程》](https://www.quanxiaoha.com/column/10005.html) ：

![img](http://public.file.lvshuhuai.cn/images\169277397264386.jpeg)

创建成功后，删除一些无用的文件、文件夹，模块结构如下：

![img](http://public.file.lvshuhuai.cn/images\169283569038529.jpeg)

修改 `pom.xml` 文件，内容如下：

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <parent>
        <groupId>com.quanxiaoha</groupId>
        <artifactId>weblog-springboot</artifactId>
        <version>${revision}</version>
    </parent>

    <groupId>com.quanxiaoha</groupId>
    <artifactId>weblog-module-jwt</artifactId>
    <name>weblog-module-jwt</name>
    <description>weblog-module-jwt (JWT 模块，管理用户认证、鉴权)</description>

    <dependencies>
        <!-- 免写冗余的 Java 样板式代码 -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- 单元测试 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

另外，还需在父项目 `weblog-springboot` 的 `pom.xml` 文件中添加 `jwt` 子模块 :

```xml
    <!-- 子模块管理 -->
    <modules>
        // 省略...
        <!-- JWT 模块 -->
        <module>weblog-module-jwt</module>
    </modules>
    
    <!-- 统一依赖管理 -->
    <dependencyManagement>
        <dependencies>
            // 省略...

            <dependency>
                <groupId>com.quanxiaoha</groupId>
                <artifactId>weblog-module-jwt</artifactId>
                <version>${revision}</version>
            </dependency>

            // 省略...
        </dependencies>
    </dependencyManagement>
```

最后，在 `weblog-module-admin` 模块中，引入 `weblog-module-jwt` 模块，因为认证、鉴权功能只有 `admin` 后台需要：

```xml
        <dependency>
            <groupId>com.quanxiaoha</groupId>
            <artifactId>weblog-module-jwt</artifactId>
        </dependency>
```

## 开始整合 Spring Security

### 添加 Spring Security 依赖

分别在 `weblog-module-admin` 和 `weblog-module-jwt` 子模块中，添加 `security` 依赖，因为这两个模块都会使用到 `spring security`框架中的功能：

```xml
		<!-- Spring Security -->
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-security</artifactId>
		</dependency>
```

### 自定义 Spring Security 配置

要更好地控制 Spring Security 的行为，你可以创建一个自定义的 `SecurityConfig` 类，继承自 `WebSecurityConfigurerAdapter`。通过覆盖方法，您可以配置认证、授权规则、自定义登录页面、注销等。

我们在 `weblog-module-admin` 模块中的 `config` 包下，创建一个 `WebSecurityConfig` 配置类，代码如下：

```java
package shuhuai.weblogbackend.admin.config;

import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

/**
 * &#064;description:  Spring Security 配置类
 **/
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.authorizeHttpRequests()
                .mvcMatchers("/admin/**").authenticated() // 认证所有以 /admin 为前缀的 URL 资源
                .anyRequest().permitAll().and() // 其他都需要放行，无需认证
                .formLogin().and() // 使用表单登录
                .httpBasic(); // 使用 HTTP Basic 认证
    }
}
```

上述代码中，我们重写了 `configure()` 方法，在该方法中，指定了对所有以 `/admin` 为前缀的请求需要进行安全认证，另外，对其他请求均放行，无需认证，因为博客前台的页面是任何人都可以访问的。最后，通过 `formLogin()` 方法指定使用表单登录，并使用 使用 HTTP Basic 认证。

> *什么是 HTTP Basic 认证？*
>
> HTTP Basic 认证是 Spring Security 中的一种认证方式，它基于 HTTP 基本认证协议。这种认证方式是一种简单的认证方式，适用于简单的应用场景。当客户端发送请求时，会将用户名和密码使用 Base64 编码的形式放在请求头中，服务器接收到请求后会解码并验证这些信息。

### 自定义登录用户名、密码

通过编辑 `applicaiton-dev.yml` 文件，添加如下配置，可以自定义测试环境下的登录用户名、密码：

```yaml
spring:
  // 省略...
  security:
    user:
      name: admin # 登录用户名
      password: 123456 # 登录密码
```

## 试试效果

自定义好了 Spring Security 的配置后，我们将之前的 `/test` 接口改为 `/admin/test` , 看看 Spring security 框架是否能够正确拦截，并跳转表单认证。

![img](http://public.file.lvshuhuai.cn/images\169277990569141.jpeg)

重启项目，在浏览器中访问 `http://localhost:8080/admin/test` , 效果图如下：

![img](http://public.file.lvshuhuai.cn/images\169277998367864.jpeg)

可以看到，正常被拦截了，并跳转到了登录表单页。这里我们输入之前自定义的用户名、密码，看看认证成功后，能够正常访问接口：

![img](http://public.file.lvshuhuai.cn/images\169278024408711.jpeg)

提示的是全局异常返回的 JSON 提示信息。这是正常的，应为浏览器是通过 `GET` 请求访问的该接口，而我们定义的是 `POST` 请求:

![img](http://public.file.lvshuhuai.cn/images\169278033003151.jpeg)

无伤大雅，但是说明了认证成功后，接口的确能被正常访问。测试成功。

## 本小节对应源码

https://t.zsxq.com/11PbLBzv8

## 结语

本小节中，我们初步整合了 Spring Security 框架，并自定义了表单认证来对 `/admin/**` 路径在未登录的情况下，进行拦截。但是，在实际的前后端分离项目中，往往不是这样玩的，通常的做法是通过 Spring Security + JWT（JSON Web Token）来实现用户的安全身份验证和授权机制。我们将在后续小节中，一步一步实现它。

# Spring Security 整合 JWT ：实现身份认证

![img](http://public.file.lvshuhuai.cn/images\169296010522522.jpeg)

## 什么是 JWT？

JWT（JSON Web Token）是一种用于在不同应用之间安全传输信息的开放标准（RFC 7519）。它是一种基于 JSON 的轻量级令牌，由三部分组成：头部（Header）、载荷（Payload）和签名（Signature）。JWT 被广泛用于实现身份验证和授权，**特别适用于前后端分离的应用程序**。

令牌类似下面这一大长串：

```undefined
eyJhbGciOiJIUzUxMiJ9.eyJzdWIiOiJxdWFueGlhb2hhIiwiaXNzIjoicXVhbnhpYW9oYSIsImlhdCI6MTY5Mjk1OTY2MSwiZXhwIjoxNjkyOTYzMjYxfQ.wbqbn23C9vAe5sQZRCBzrIM4SiN1eNl55NIONmHoiPHPHSSu0QJGgPGUin80hA4XgMHEqN1Wm5KJlmKKucUyGQ
```

可以看到，由 `header.payload.signature` 三部分组成，你可以在此网站: https://jwt.io/ 上获得解析结果：

![img](http://public.file.lvshuhuai.cn/images\169295993162081.jpeg)

## 为什么要使用 JWT？

JWT 提供了一种在客户端和服务器之间传输安全信息的简单方法，具有以下优点：

- **无状态性（Stateless）**：JWT 本身包含了所有必要的信息，无需在服务器端存储会话信息，每个请求都可以独立验证。
- **灵活性**：JWT 可以存储任意格式的数据，使其成为传递用户信息、权限、角色等的理想选择。
- **安全性**：JWT 使用签名进行验证，确保信息在传输过程中不被篡改。
- **跨平台和跨语言**：由于 JWT 使用 JSON 格式，它在不同的编程语言和平台之间都可以轻松传递。

## 开始动手

### 添加 JWT 依赖

这里我们选择 Java JWT : JSON Web Token for Java and Android (简称 JJWT) 库。首先，在 `weblog-springboot` 父模块中的 `pom.xml` 中声明版本号：

```xml
    <!-- 版本号统一管理 -->
    <properties>
        // 省略...
        <jjwt.version>0.11.2</jjwt.version>
    </properties>
    
       <!-- 统一依赖管理 -->
    <dependencyManagement>
        <dependencies>
            <!--   JWT   -->
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-api</artifactId>
                <version>${jjwt.version}</version>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-impl</artifactId>
                <version>${jjwt.version}</version>
            </dependency>
            <dependency>
                <groupId>io.jsonwebtoken</groupId>
                <artifactId>jjwt-jackson</artifactId>
                <version>${jjwt.version}</version>
            </dependency>
			
        </dependencies>
    </dependencyManagement>
```

然后，在 `weblog-module-jwt` 模块中的 `pom.xml` 文件中，引入该依赖，添加内容如下：

```xml
        <!-- JWT -->
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-api</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-impl</artifactId>
        </dependency>
        <dependency>
            <groupId>io.jsonwebtoken</groupId>
            <artifactId>jjwt-jackson</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- 工具包 -->
        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>

        <!-- 通用模块 -->
        <dependency>
            <groupId>com.quanxiaoha</groupId>
            <artifactId>weblog-module-common</artifactId>
        </dependency>
		
		<dependency>
            <groupId>com.fasterxml.jackson.core</groupId>
            <artifactId>jackson-core</artifactId>
        </dependency>
```

上述代码中，除了添加了 `jwt` 相关依赖外，还添加了 `commons-lang3`、`weblog-module-common` 等，这小节后续的编码中，会使用到其中的功能。

### 编写 JwtTokenHelper 工具类

接下来，我们来封装一个 `JwtTokenHelper` 工具类，封装所有 `JWT` 相关的功能。

```java
@Component
public class JwtTokenHelper implements InitializingBean {

    /**
     * 签发人
     */
    @Value("${jwt.issuer}")
    private String issuer;
    /**
     * 秘钥
     */
    private Key key;

    /**
     * JWT 解析
     */
    private JwtParser jwtParser;

    /**
     * 解码配置文件中配置的 Base 64 编码 key 为秘钥
     * @param base64Key
     */
    @Value("${jwt.secret}")
    public void setBase64Key(String base64Key) {
        key = Keys.hmacShaKeyFor(Base64.getDecoder().decode(base64Key));
    }


    /**
     * 初始化 JwtParser
     * @throws Exception
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        // 考虑到不同服务器之间可能存在时钟偏移，setAllowedClockSkewSeconds 用于设置能够容忍的最大的时钟误差
        jwtParser = Jwts.parserBuilder().requireIssuer(issuer)
                .setSigningKey(key).setAllowedClockSkewSeconds(10)
                .build();
    }

    /**
     * 生成 Token
     * @param username
     * @return
     */
    public String generateToken(String username) {
        LocalDateTime now = LocalDateTime.now();
        // Token 一个小时后失效
        LocalDateTime expireTime = now.plusHours(1);

        return Jwts.builder().setSubject(username)
                .setIssuer(issuer)
                .setIssuedAt(Date.from(now.atZone(ZoneId.systemDefault()).toInstant()))
                .setExpiration(Date.from(expireTime.atZone(ZoneId.systemDefault()).toInstant()))
                .signWith(key)
                .compact();
    }

    /**
     * 解析 Token
     * @param token
     * @return
     */
    public Jws<Claims> parseToken(String token) {
        try {
            return jwtParser.parseClaimsJws(token);
        } catch (SignatureException | MalformedJwtException | UnsupportedJwtException | IllegalArgumentException e) {
            throw new BadCredentialsException("Token 不可用", e);
        } catch (ExpiredJwtException e) {
            throw new CredentialsExpiredException("Token 失效", e);
        }
    }

    /**
     * 生成一个 Base64 的安全秘钥
     * @return
     */
    private static String generateBase64Key() {
        // 生成安全秘钥
        Key secretKey = Keys.secretKeyFor(SignatureAlgorithm.HS512);

        // 将密钥进行 Base64 编码
        String base64Key = Base64.getEncoder().encodeToString(secretKey.getEncoded());

        return base64Key;
    }

    public static void main(String[] args) {
        String key = generateBase64Key();
        System.out.println("key: " + key);
    }
}
```

上述代码中，`Token` 令牌的初始化工作在 `generateToken()` 方法中完成，主要是通过 `Jwts.builder` 返回的 `JwtBuilder` 来做的。令牌的解析工作交给了 `JwtParser` 类，在 `parseToken()` 方法中完成。

与之对应的，工具类中注入的一些参数，如 `jwt` 的签发人、秘钥，需要在 `applicaiton.yml` 中配置好：

```yaml
jwt:
  # 签发人
  issuer: quanxiaoha
  # 秘钥
  secret: jElxcSUj38+Bnh73T68lNs0DfBSit6U3whQlcGO2XwnI+Bo3g4xsiCIPg8PV/L0fQMis08iupNwhe2PzYLB9Xg==
```

#### 如何生成安全的秘钥？

小伙伴们可能会有疑问，配置文件中的这一串这么长的秘钥怎么来的？其实，小哈在 `JwtTokenHelper` 中，已经定义好了一个 `generateBase64Key()` 方法，它专门用于生成一个 Base64 的安全秘钥，执行 `main()` 方法即可，然后将生成好的秘钥配置到 `yml` 文件中。

### PasswordEncoder 密码加密

在系统中，安全存储用户密码是至关重要的。使用明文存储密码容易受到攻击，相信小伙伴们都看过某些网站用户账户被黑，密码都是明文保存的新闻，因此使用密码加密技术来保护用户密码是必不可少的。

#### 密码加密的重要性

- **安全性：** 存储加密后的密码可以防止明文密码泄漏，即使数据库被攻击也不会暴露用户的真实密码。
- **防御攻击：** 使用密码哈希算法可以防止常见的攻击，如彩虹表攻击。
- **隐私保护：** 用户的密码是敏感信息，应当采取措施来保护用户的隐私。

在 `weblog-module-jwt` 模块中新建 `config` 包，并创建 `PasswordEncoderConfig` 配置类，代码如下：

```typescript
@Component
public class PasswordEncoderConfig {

    @Bean
    public PasswordEncoder passwordEncoder() {
	    // BCrypt 是一种安全且适合密码存储的哈希算法，它在进行哈希时会自动加入“盐”，增加密码的安全性。
        return new BCryptPasswordEncoder();
    }

    public static void main(String[] args) {
        BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
        System.out.println(encoder.encode("quanxiaoha"));
    }
}
```

> **PasswordEncoder 接口**
>
> `PasswordEncoder` 接口是 Spring Security 提供的密码加密接口，它定义了密码加密和密码验证的方法。通过实现这个接口，您可以将密码加密为不可逆的哈希值，以及在验证密码时对比哈希值。

上述代码中，我们初始化了一个 `PasswordEncoder` 接口的具体实现类 `BCryptPasswordEncoder`。`BCryptPasswordEncoder` 是 Spring Security 提供的密码加密器的一种实现，使用 BCrypt 算法对密码进行加密。BCrypt 是一种安全且适合密码存储的哈希算法，它在进行哈希时会自动加入“盐”，增加密码的安全性。

### 实现 UserDetailsService：Spring Security 用户详情服务

##### 什么是 UserDetailsService？

`UserDetailsService` 是 Spring Security 提供的接口，用于从应用程序的数据源（如数据库、LDAP、内存等）中加载用户信息。它是一个用于将用户详情加载到 Spring Security 的中心机制。`UserDetailsService` 主要负责两项工作：

1. **加载用户信息：** 从数据源中加载用户的用户名、密码和角色等信息。
2. **创建 UserDetails 对象：** 根据加载的用户信息，创建一个 Spring Security 所需的 `UserDetails` 对象，包含用户名、密码、角色和权限等。

#### 自定义实现类

新建 `service` 包，并创建 `UserDetailServiceImpl` 实现类：

![img](http://public.file.lvshuhuai.cn/images\169292928688850.jpeg)

```less
@Service
@Slf4j
public class UserDetailServiceImpl implements UserDetailsService {
    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 从数据库中查询
        // ...

		// 暂时先写死，密码为 quanxiaoha, 这里填写的密文，数据库中也是存储此种格式
		// authorities 用于指定角色，这里写死为 ADMIN 管理员
        return User.withUsername("quanxiaoha")
                .password("$2a$10$n7RJ1q.RnXx5M3O6B0i0he04fZOPjIJpyWcKuicW1bFyFHWhlGose")
                .authorities("ADMIN")
                .build();
    }
}
```

上述代码中，我们实现了 `UserDetailsService` 接口，并重写了 `loadUserByUsername()` 方法，该方法用于根据用户名加载用户信息的逻辑 ，正常需要从数据库中查询，这里我们先写死，继续开发后面的功能，后续再回过头来改造。

### 自定义认证过滤器

接下来，我们自定义一个用于认证的过滤器，新建 `/filter` 包，并创建 `JwtAuthenticationFilter` 过滤器，代码如下：

```java
public class JwtAuthenticationFilter extends AbstractAuthenticationProcessingFilter {


    /**
     * 指定用户登录的访问地址
     */
    public JwtAuthenticationFilter() {
        super(new AntPathRequestMatcher("/login", "POST"));
    }

    @Override
    public Authentication attemptAuthentication(HttpServletRequest request, HttpServletResponse response) throws AuthenticationException, IOException, ServletException {
        ObjectMapper mapper = new ObjectMapper();
        // 解析提交的 JSON 数据
        JsonNode jsonNode = mapper.readTree(request.getInputStream());
        JsonNode usernameNode = jsonNode.get("username");
        JsonNode passwordNode =  jsonNode.get("password");

        // 判断用户名、密码是否为空
        if (Objects.isNull(usernameNode) || Objects.isNull(passwordNode)
            || StringUtils.isBlank(usernameNode.textValue()) || StringUtils.isBlank(passwordNode.textValue())) {
            throw new UsernameOrPasswordNullException("用户名或密码不能为空");
        }

        String username = usernameNode.textValue();
        String password = passwordNode.textValue();

        // 将用户名、密码封装到 Token 中
        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken
                = new UsernamePasswordAuthenticationToken(username, password);
        return getAuthenticationManager().authenticate(usernamePasswordAuthenticationToken);
    }
}
```

此过滤器继承了 `AbstractAuthenticationProcessingFilter`，用于处理 JWT（JSON Web Token）的用户身份验证过程。在构造函数中，调用了父类 `AbstractAuthenticationProcessingFilter` 的构造函数，通过 `AntPathRequestMatcher` 指定了处理用户登录的访问地址。这意味着当请求路径匹配 `/login` 并且请求方法为 `POST` 时，该过滤器将被触发。

`attemptAuthentication()` 方法用于实现用户身份验证的具体逻辑。首先，我们解析了提交的 JSON 数据，并获取了用户名、密码，校验是否为空，若不为空，则将它们封装到 `UsernamePasswordAuthenticationToken` 中。最后，使用 `getAuthenticationManager().authenticate()` 来触发 Spring Security 的身份验证管理器执行实际的身份验证过程，然后返回身份验证结果。

#### 自定义用户名或密码不能为空异常

上面过滤器代码中，有个动作是校验用户名、密码是否为空，为空则抛出 `UsernameOrPasswordNullException` 异常，此类是自定义的得来的。新建包 `/exception`, 在此包中创建该类：

![img](http://public.file.lvshuhuai.cn/images\169293318187296.jpeg)

```java
public class UsernameOrPasswordNullException extends AuthenticationException {
    public UsernameOrPasswordNullException(String msg, Throwable cause) {
        super(msg, cause);
    }

    public UsernameOrPasswordNullException(String msg) {
        super(msg);
    }
}
```

注意，需继承自 `AuthenticationException`，只有该类型异常，才能被后续自定义的认证失败处理器捕获到。

### 自定义处理器

用户登录后，我们还需要处理其对应的结果，如登录成功，则返回 `Token` 令牌，登录失败，则返回对应的提示信息。在 Spring Security 中，`AuthenticationFailureHandler` 和 `AuthenticationSuccessHandler` 是用于处理身份验证失败和成功的接口。它们允许您在用户身份验证过程中自定义响应，以便更好地控制和定制用户体验。

#### 自定义认证成功处理器 RestAuthenticationSuccessHandler

新建 `/handler` 包，并创建 `RestAuthenticationSuccessHandler` 类：

```java
@Component
@Slf4j
public class RestAuthenticationSuccessHandler implements AuthenticationSuccessHandler {
    @Autowired
    private JwtTokenHelper jwtTokenHelper;

    @Override
    public void onAuthenticationSuccess(HttpServletRequest request, HttpServletResponse response, Authentication authentication) throws IOException, ServletException {
        // 从 authentication 对象中获取用户的 UserDetails 实例，这里是获取用户的用户名
        UserDetails userDetails = (UserDetails) authentication.getPrincipal();

        // 通过用户名生成 Token
        String username = userDetails.getUsername();
        String token = jwtTokenHelper.generateToken(username);

        // 返回 Token
        LoginRspVO loginRspVO = LoginRspVO.builder().token(token).build();

        ResultUtil.ok(response, Response.success(loginRspVO));
    }
}
```

此类实现了 Spring Security 的 `AuthenticationSuccessHandler` 接口，用于处理身份验证成功后的逻辑。首先，从 authentication 对象中获取用户的 UserDetails 实例，这里是主要是获取用户的用户名，然后通过用户名生成 `Token` 令牌，最后返回数据。

##### LoginRspVO

此类是登录的响参类，`VO` (View Object) 表示和视图相关的实体类，`rsp` 是 `response` 的缩写，表示返参，对应的 `req` 是 `request` 的缩写，表示请求。小哈习惯上对 `VO` 类的命名规则是：*动作 + 请求标识/响应标识 + VO*，如 `LoginReqVO`、`LoginRspVO` 等，这样做的好处是，可以一眼看出此类的作用，方便后续维护。

`LoginRspVO` 实体类对应内容如下：

```less
@Data
@AllArgsConstructor
@NoArgsConstructor
@Builder
public class LoginRspVO {

    /**
     * Token 值
     */
    private String token;

}
```

##### ResultUtil 返参工具类

为了在过滤器中方便的返回 JSON 参数，我们需要封装一个工具类 `ResultUtil`， 放置在 `/utils` 包下，代码如下：

```java
public class ResultUtil {

    /**
     * 成功响参
     * @param response
     * @param result
     * @throws IOException
     */
    public static void ok(HttpServletResponse response, Response<?> result) throws IOException {
        response.setCharacterEncoding("UTF-8");
        response.setStatus(HttpStatus.OK.value());
        response.setContentType("application/json");
        PrintWriter writer = response.getWriter();

        ObjectMapper mapper = new ObjectMapper();
        writer.write(mapper.writeValueAsString(result));
        writer.flush();
        writer.close();
    }

    /**
     * 失败响参
     * @param response
     * @param result
     * @throws IOException
     */
    public static void fail(HttpServletResponse response, Response<?> result) throws IOException {
        response.setCharacterEncoding("UTF-8");
        response.setStatus(HttpStatus.OK.value());
        response.setContentType("application/json");
        PrintWriter writer = response.getWriter();

        ObjectMapper mapper = new ObjectMapper();
        writer.write(mapper.writeValueAsString(result));
        writer.flush();
        writer.close();
    }

    /**
     * 失败响参
     * @param response
     * @param status 可指定响应码，如 401 等
     * @param result
     * @throws IOException
     */
    public static void fail(HttpServletResponse response, int status, Response<?> result) throws IOException {
        response.setCharacterEncoding("UTF-8");
        response.setStatus(status);
        response.setContentType("application/json");
        PrintWriter writer = response.getWriter();

        ObjectMapper mapper = new ObjectMapper();
        writer.write(mapper.writeValueAsString(result));
        writer.flush();
        writer.close();
    }
}
```

#### 自定义认证失败处理器

在 `/handler` 包下，创建 `RestAuthenticationFailureHandler` 认证失败处理器：

```\
@Component
@Slf4j
public class RestAuthenticationFailureHandler implements AuthenticationFailureHandler {
    @Override
    public void onAuthenticationFailure(HttpServletRequest request, HttpServletResponse response, AuthenticationException exception) throws IOException, ServletException {
        log.warn("AuthenticationException: ", exception);
        if (exception instanceof UsernameOrPasswordNullException) {
            // 用户名或密码为空
            ResultUtil.fail(response, Response.fail(exception.getMessage()));
        } else if (exception instanceof BadCredentialsException) {
            // 用户名或密码错误
            ResultUtil.fail(response, Response.fail(ResponseCodeEnum.USERNAME_OR_PWD_ERROR));
        }

        // 登录失败
        ResultUtil.fail(response, Response.fail(ResponseCodeEnum.LOGIN_FAIL));
    }
}
```

通过自定义了一个实现了 Spring Security 的 `AuthenticationFailureHandler` 接口类，用于在用户身份验证失败后执行一些逻辑。首先，我们打印了异常日志，方便后续定位问题，然后对异常的类型进行判断，通过 `ResultUtil` 工具类，返回不同的错误信息，如用户名或者密码为空、用户名或密码错误等，若未判断出异常是什么类型，则统一提示为 *登录失败*。

##### ResponseCodeEnum

编辑 `weblog-module-common` 模块中的 `ResponseCodeEnum` 枚举类，添加登录失败的响应码：

```bash
LOGIN_FAIL("20000", "登录失败"),
USERNAME_OR_PWD_ERROR("20001", "用户名或密码错误"),
```

### 自定义 JWT 认证功能配置

完成了以上前置工作后，我们开始配置 `JWT` 认证相关的配置。在 `/config` 包下新建 `JwtAuthenticationSecurityConfig`, 代码如下：

```java
@Configuration
public class JwtAuthenticationSecurityConfig extends SecurityConfigurerAdapter<DefaultSecurityFilterChain, HttpSecurity> {

    @Autowired
    private RestAuthenticationSuccessHandler restAuthenticationSuccessHandler;

    @Autowired
    private RestAuthenticationFailureHandler restAuthenticationFailureHandler;

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Autowired
    private UserDetailsService userDetailsService;

    @Override
    public void configure(HttpSecurity httpSecurity) throws Exception {
        // 自定义的用于 JWT 身份验证的过滤器
        JwtAuthenticationFilter filter = new JwtAuthenticationFilter();
        filter.setAuthenticationManager(httpSecurity.getSharedObject(AuthenticationManager.class));

        // 设置登录认证对应的处理类（成功处理、失败处理）
        filter.setAuthenticationSuccessHandler(restAuthenticationSuccessHandler);
        filter.setAuthenticationFailureHandler(restAuthenticationFailureHandler);

        // 直接使用 DaoAuthenticationProvider, 它是 Spring Security 提供的默认的身份验证提供者之一
        DaoAuthenticationProvider provider = new DaoAuthenticationProvider();
        // 设置 userDetailService，用于获取用户的详细信息
        provider.setUserDetailsService(userDetailsService);
        // 设置加密算法
        provider.setPasswordEncoder(passwordEncoder);
        httpSecurity.authenticationProvider(provider);
        // 将这个过滤器添加到 UsernamePasswordAuthenticationFilter 之前执行
        httpSecurity.addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class);
    }
}
```

上述代码是一个 Spring Security 配置类，用于配置 JWT（JSON Web Token）的身份验证机制。它继承了 Spring Security 的 `SecurityConfigurerAdapter` 类，用于在 Spring Security 配置中添加自定义的认证过滤器和提供者。通过重写 `configure()` 方法，我们将之前写好过滤器、认证成功、失败处理器，以及加密算法整合到了 `httpSecurity` 中。

### 应用 JWT 认证功能配置

接下来，我们编辑 `weblog-module-admin` 中的 Spring Security 配置 `WebSecurityConfig` 类，修改内容如下：

```scss
@Configuration
@EnableWebSecurity
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {

    @Autowired
    private JwtAuthenticationSecurityConfig jwtAuthenticationSecurityConfig;

    @Override
    protected void configure(HttpSecurity http) throws Exception {
        http.csrf().disable(). // 禁用 csrf
                formLogin().disable() // 禁用表单登录
                .apply(jwtAuthenticationSecurityConfig) // 设置用户登录认证相关配置
             .and()
                .authorizeHttpRequests()
                .mvcMatchers("/admin/**").authenticated() // 认证所有以 /admin 为前缀的 URL 资源
                .anyRequest().permitAll() // 其他都需要放行，无需认证
             .and()
                .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); // 前后端分离，无需创建会话
    }
}
```

上述代码中，在 `configure()` 方法中，首先禁用了 CSRF（Cross-Site Request Forgery）攻击防护。在前后端分离的情况下，通常不需要启用 CSRF 防护。同时，还禁用了表单登录，并应用了 `JWT` 相关的配置类 `JwtAuthenticationSecurityConfig`。最后，配置会话管理这块，将会话策略设置为无状态（`STATELESS`），适用于前后端分离的情况，无需创建会话。

## 工程目录

上述功能代码搞定后，基本结构如下，小伙伴们可对照一下：

![img](http://public.file.lvshuhuai.cn/images\169295181421345.jpeg)

## 测试一波登录接口

重启项目，访问 `http://localhost:8080/doc.html` 接口文档，因为 `Knife4j` 扫描的是 `Controller` 包，而 `/login` 接口定义在了过滤器 `JwtAuthenticationFilter` 中, 所以接口文档中并不会出现它。针对这个独特的接口，我们需要手动来调试它。

### 用户名、密码为空

手动改写接口请求路径为 `/login` 以及入参，测试一波用户名、密码为空的情况，可以看到提示信息正确：

![img](http://public.file.lvshuhuai.cn/images\169295272610077.jpeg)

### 用户名、密码错误

再来测试一波用户名、密码错误的情况：

![img](http://public.file.lvshuhuai.cn/images\169295287943147.jpeg)

### 用户名、密码正确

当用户名、密码正确的时候，接口应该返回 `Token` 令牌：

![img](http://public.file.lvshuhuai.cn/images\169295352270645.jpeg)

可以看到，正确返回了 `Token` 令牌，说明认证功能基本搞定了。

## 从数据库中查询用户信息

前面我们根据用户名查询用户信息这块，是代码中写死的。接下来，我们将其改造为从数据库中查询。首先，我们将 `t_user` 表中之前用于测试的记录删除干净：

```swift
INSERT INTO `weblog`.`t_user` (`username`, `password`, `create_time`, `update_time`, `is_deleted`) VALUES ('quanxiaoha', '$2a$10$n7RJ1q.RnXx5M3O6B0i0he04fZOPjIJpyWcKuicW1bFyFHWhlGose', now(), now(), 0);
```

然后, 编辑 `UserMapper` 接口，添加一个根据用户名查询信息的默认方法：

```typescript
public interface UserMapper extends BaseMapper<UserDO> {
    default UserDO findByUsername(String username) {
        LambdaQueryWrapper<UserDO> wrapper = new LambdaQueryWrapper<>();
        wrapper.eq(UserDO::getUsername, username);
        return selectOne(wrapper);
    }
}
```

最后，编辑 `UserDetailServiceImpl` 类，改为从数据库中查询：

```java
@Service
@Slf4j
public class UserDetailServiceImpl implements UserDetailsService {

    @Autowired
    private UserMapper userMapper;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 从数据库中查询
        UserDO userDO = userMapper.findByUsername(username);

        // 判断用户是否存在
        if (Objects.isNull(userDO)) {
            throw new UsernameNotFoundException("该用户不存在");
        }

        // authorities 用于指定角色，这里写死为 ADMIN 管理员
        return User.withUsername(userDO.getUsername())
                .password(userDO.getPassword())
                .authorities("ADMIN")
                .build();
    }
}
```

## 最后再测试一波

改走数据库中查询用户信息后，重启项目，最后我们再测试一下 `/login` 接口是否正常：

![img](http://public.file.lvshuhuai.cn/images\169295592430310.jpeg)

可以看到一切正常，走数据库验证用户名、密码也是 OK 的。

## 本小节对应源码

https://t.zsxq.com/11ujBCKTh

## 结语

Spring Security JWT 提供了一种安全且灵活的方式来实现身份验证和授权，适用于前后端分离的应用程序。通过使用 JWT，您可以实现无状态的身份验证机制，提高应用程序的安全性和可维护性。注意，本小节中，我们只完成了认证模块（用户登录），鉴权模块我们将在下小节中开发，敬请期待。